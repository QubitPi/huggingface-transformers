import{s as yt,o as Mt,n as tt}from"../chunks/scheduler.9bc65507.js";import{S as kt,i as Et,g as i,s as n,r as h,A as xt,h as l,f as o,c as a,j as z,u as f,x as u,k as U,y as s,a as d,v as g,d as _,t as b,w as v}from"../chunks/index.707bf1b6.js";import{T as Tt}from"../chunks/Tip.c2ecdbf4.js";import{D as ae}from"../chunks/Docstring.17db21ae.js";import{C as ot}from"../chunks/CodeBlock.54a9f38d.js";import{E as wt}from"../chunks/ExampleCodeBlock.4f515aa9.js";import{H as be}from"../chunks/Heading.342b1fa6.js";function $t(W){let c,E="Example:",p,m,w;return m=new ot({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEVuY29kZWNNb2RlbCUyQyUyMEVuY29kZWNDb25maWclMEElMEElMjMlMjBJbml0aWFsaXppbmclMjBhJTIwJTIyZmFjZWJvb2slMkZlbmNvZGVjXzI0a2h6JTIyJTIwc3R5bGUlMjBjb25maWd1cmF0aW9uJTBBY29uZmlndXJhdGlvbiUyMCUzRCUyMEVuY29kZWNDb25maWcoKSUwQSUwQSUyMyUyMEluaXRpYWxpemluZyUyMGElMjBtb2RlbCUyMCh3aXRoJTIwcmFuZG9tJTIwd2VpZ2h0cyklMjBmcm9tJTIwdGhlJTIwJTIyZmFjZWJvb2slMkZlbmNvZGVjXzI0a2h6JTIyJTIwc3R5bGUlMjBjb25maWd1cmF0aW9uJTBBbW9kZWwlMjAlM0QlMjBFbmNvZGVjTW9kZWwoY29uZmlndXJhdGlvbiklMEElMEElMjMlMjBBY2Nlc3NpbmclMjB0aGUlMjBtb2RlbCUyMGNvbmZpZ3VyYXRpb24lMEFjb25maWd1cmF0aW9uJTIwJTNEJTIwbW9kZWwuY29uZmln",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> EncodecModel, EncodecConfig

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a &quot;facebook/encodec_24khz&quot; style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = EncodecConfig()

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a model (with random weights) from the &quot;facebook/encodec_24khz&quot; style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = EncodecModel(configuration)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Accessing the model configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = model.config`,wrap:!1}}),{c(){c=i("p"),c.textContent=E,p=n(),h(m.$$.fragment)},l(r){c=l(r,"P",{"data-svelte-h":!0}),u(c)!=="svelte-11lpom8"&&(c.textContent=E),p=a(r),f(m.$$.fragment,r)},m(r,M){d(r,c,M),d(r,p,M),g(m,r,M),w=!0},p:tt,i(r){w||(_(m.$$.fragment,r),w=!0)},o(r){b(m.$$.fragment,r),w=!1},d(r){r&&(o(c),o(p)),v(m,r)}}}function jt(W){let c,E=`Although the recipe for forward pass needs to be defined within this function, one should call the <code>Module</code>
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`;return{c(){c=i("p"),c.innerHTML=E},l(p){c=l(p,"P",{"data-svelte-h":!0}),u(c)!=="svelte-fincs2"&&(c.innerHTML=E)},m(p,m){d(p,c,m)},p:tt,d(p){p&&o(c)}}}function Ct(W){let c,E="Examples:",p,m,w;return m=new ot({props:{code:"ZnJvbSUyMGRhdGFzZXRzJTIwaW1wb3J0JTIwbG9hZF9kYXRhc2V0JTBBZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Qcm9jZXNzb3IlMkMlMjBFbmNvZGVjTW9kZWwlMEElMEFkYXRhc2V0JTIwJTNEJTIwbG9hZF9kYXRhc2V0KCUyMmFzaHJhcSUyRmVzYzUwJTIyKSUwQWF1ZGlvX3NhbXBsZSUyMCUzRCUyMGRhdGFzZXQlNUIlMjJ0cmFpbiUyMiU1RCU1QiUyMmF1ZGlvJTIyJTVEJTVCMCU1RCU1QiUyMmFycmF5JTIyJTVEJTBBJTBBbW9kZWxfaWQlMjAlM0QlMjAlMjJmYWNlYm9vayUyRmVuY29kZWNfMjRraHolMjIlMEFtb2RlbCUyMCUzRCUyMEVuY29kZWNNb2RlbC5mcm9tX3ByZXRyYWluZWQobW9kZWxfaWQpJTBBcHJvY2Vzc29yJTIwJTNEJTIwQXV0b1Byb2Nlc3Nvci5mcm9tX3ByZXRyYWluZWQobW9kZWxfaWQpJTBBJTBBaW5wdXRzJTIwJTNEJTIwcHJvY2Vzc29yKHJhd19hdWRpbyUzRGF1ZGlvX3NhbXBsZSUyQyUyMHJldHVybl90ZW5zb3JzJTNEJTIycHQlMjIpJTBBJTBBb3V0cHV0cyUyMCUzRCUyMG1vZGVsKCoqaW5wdXRzKSUwQWF1ZGlvX2NvZGVzJTIwJTNEJTIwb3V0cHV0cy5hdWRpb19jb2RlcyUwQWF1ZGlvX3ZhbHVlcyUyMCUzRCUyMG91dHB1dHMuYXVkaW9fdmFsdWVz",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoProcessor, EncodecModel

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;ashraq/esc50&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>audio_sample = dataset[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-string">&quot;audio&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;array&quot;</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>model_id = <span class="hljs-string">&quot;facebook/encodec_24khz&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = EncodecModel.from_pretrained(model_id)
<span class="hljs-meta">&gt;&gt;&gt; </span>processor = AutoProcessor.from_pretrained(model_id)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = processor(raw_audio=audio_sample, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>audio_codes = outputs.audio_codes
<span class="hljs-meta">&gt;&gt;&gt; </span>audio_values = outputs.audio_values`,wrap:!1}}),{c(){c=i("p"),c.textContent=E,p=n(),h(m.$$.fragment)},l(r){c=l(r,"P",{"data-svelte-h":!0}),u(c)!=="svelte-kvfsh7"&&(c.textContent=E),p=a(r),f(m.$$.fragment,r)},m(r,M){d(r,c,M),d(r,p,M),g(m,r,M),w=!0},p:tt,i(r){w||(_(m.$$.fragment,r),w=!0)},o(r){b(m.$$.fragment,r),w=!1},d(r){r&&(o(c),o(p)),v(m,r)}}}function Jt(W){let c,E,p,m,w,r,M,we,q,nt='The EnCodec neural codec model was proposed in <a href="https://arxiv.org/abs/2210.13438" rel="nofollow">High Fidelity Neural Audio Compression</a> by Alexandre DÃ©fossez, Jade Copet, Gabriel Synnaeve, Yossi Adi.',ye,B,at="The abstract from the paper is the following:",Me,X,st="<em>We introduce a state-of-the-art real-time, high-fidelity, audio codec leveraging neural networks. It consists in a streaming encoder-decoder architecture with quantized latent space trained in an end-to-end fashion. We simplify and speed-up the training by using a single multiscale spectrogram adversary that efficiently reduces artifacts and produce high-quality samples. We introduce a novel loss balancer mechanism to stabilize training: the weight of a loss now defines the fraction of the overall gradient it should represent, thus decoupling the choice of this hyper-parameter from the typical scale of the loss. Finally, we study how lightweight Transformer models can be used to further compress the obtained representation by up to 40%, while staying faster than real time. We provide a detailed description of the key design choices of the proposed model including: training objective, architectural changes and a study of various perceptual loss functions. We present an extensive subjective evaluation (MUSHRA tests) together with an ablation study for a range of bandwidths and audio domains, including speech, noisy-reverberant speech, and music. Our approach is superior to the baselines methods across all evaluated settings, considering both 24 kHz monophonic and 48 kHz stereophonic audio.</em>",ke,G,rt=`This model was contributed by <a href="https://huggingface.co/Matthijs" rel="nofollow">Matthijs</a>, <a href="https://huggingface.co/patrickvonplaten" rel="nofollow">Patrick Von Platen</a> and <a href="https://huggingface.co/ArthurZ" rel="nofollow">Arthur Zucker</a>.
The original code can be found <a href="https://github.com/facebookresearch/encodec" rel="nofollow">here</a>.`,Ee,H,xe,P,ct="Here is a quick example of how to encode and decode an audio using this model:",Te,Y,$e,Q,je,x,L,Ie,se,dt=`This is the configuration class to store the configuration of an <a href="/docs/transformers/main/en/model_doc/encodec#transformers.EncodecModel">EncodecModel</a>. It is used to instantiate a
Encodec model according to the specified arguments, defining the model architecture. Instantiating a configuration
with the defaults will yield a similar configuration to that of the
<a href="https://huggingface.co/facebook/encodec_24khz" rel="nofollow">facebook/encodec_24khz</a> architecture.`,Fe,re,it=`Configuration objects inherit from <a href="/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig">PretrainedConfig</a> and can be used to control the model outputs. Read the
documentation from <a href="/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig">PretrainedConfig</a> for more information.`,Re,Z,Ce,S,Je,k,D,Ve,ce,lt="Constructs an EnCodec feature extractor.",qe,de,mt=`This feature extractor inherits from <a href="/docs/transformers/main/en/main_classes/feature_extractor#transformers.SequenceFeatureExtractor">SequenceFeatureExtractor</a> which contains
most of the main methods. Users should refer to this superclass for more information regarding those methods.`,Be,ie,pt=`Instantiating a feature extractor with the defaults will yield a similar configuration to that of the
<a href="https://huggingface.co/facebook/encodec_24khz" rel="nofollow">facebook/encodec_24khz</a> architecture.`,Xe,N,A,Ge,le,ut="Main method to featurize and prepare for the model one or several sequence(s).",ze,O,Ue,y,K,He,me,ht=`The EnCodec neural audio codec model.
This model inherits from <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a>. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`,Pe,pe,ft=`This model is also a PyTorch <a href="https://pytorch.org/docs/stable/nn.html#torch.nn.Module" rel="nofollow">torch.nn.Module</a> subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`,Ye,J,ee,Qe,ue,gt="Decodes the given frames into an output audio waveform.",Le,he,_t=`Note that the output might be a bit bigger than the input. In that case, any extra steps at the end can be
trimmed.`,Se,I,te,De,fe,bt="Encodes the input audio waveform into discrete codes.",Ae,$,oe,Oe,ge,vt='The <a href="/docs/transformers/main/en/model_doc/encodec#transformers.EncodecModel">EncodecModel</a> forward method, overrides the <code>__call__</code> special method.',Ke,F,et,R,We,ve,Ze;return w=new be({props:{title:"EnCodec",local:"encodec",headingTag:"h1"}}),M=new be({props:{title:"Overview",local:"overview",headingTag:"h2"}}),H=new be({props:{title:"Usage example",local:"usage-example",headingTag:"h2"}}),Y=new ot({props:{code:"ZnJvbSUyMGRhdGFzZXRzJTIwaW1wb3J0JTIwbG9hZF9kYXRhc2V0JTJDJTIwQXVkaW8lMEFmcm9tJTIwdHJhbnNmb3JtZXJzJTIwaW1wb3J0JTIwRW5jb2RlY01vZGVsJTJDJTIwQXV0b1Byb2Nlc3NvciUwQWxpYnJpc3BlZWNoX2R1bW15JTIwJTNEJTIwbG9hZF9kYXRhc2V0KCUyMmhmLWludGVybmFsLXRlc3RpbmclMkZsaWJyaXNwZWVjaF9hc3JfZHVtbXklMjIlMkMlMjAlMjJjbGVhbiUyMiUyQyUyMHNwbGl0JTNEJTIydmFsaWRhdGlvbiUyMiklMEElMEFtb2RlbCUyMCUzRCUyMEVuY29kZWNNb2RlbC5mcm9tX3ByZXRyYWluZWQoJTIyZmFjZWJvb2slMkZlbmNvZGVjXzI0a2h6JTIyKSUwQXByb2Nlc3NvciUyMCUzRCUyMEF1dG9Qcm9jZXNzb3IuZnJvbV9wcmV0cmFpbmVkKCUyMmZhY2Vib29rJTJGZW5jb2RlY18yNGtoeiUyMiklMEFsaWJyaXNwZWVjaF9kdW1teSUyMCUzRCUyMGxpYnJpc3BlZWNoX2R1bW15LmNhc3RfY29sdW1uKCUyMmF1ZGlvJTIyJTJDJTIwQXVkaW8oc2FtcGxpbmdfcmF0ZSUzRHByb2Nlc3Nvci5zYW1wbGluZ19yYXRlKSklMEFhdWRpb19zYW1wbGUlMjAlM0QlMjBsaWJyaXNwZWVjaF9kdW1teSU1Qi0xJTVEJTVCJTIyYXVkaW8lMjIlNUQlNUIlMjJhcnJheSUyMiU1RCUwQWlucHV0cyUyMCUzRCUyMHByb2Nlc3NvcihyYXdfYXVkaW8lM0RhdWRpb19zYW1wbGUlMkMlMjBzYW1wbGluZ19yYXRlJTNEcHJvY2Vzc29yLnNhbXBsaW5nX3JhdGUlMkMlMjByZXR1cm5fdGVuc29ycyUzRCUyMnB0JTIyKSUwQSUwQWVuY29kZXJfb3V0cHV0cyUyMCUzRCUyMG1vZGVsLmVuY29kZShpbnB1dHMlNUIlMjJpbnB1dF92YWx1ZXMlMjIlNUQlMkMlMjBpbnB1dHMlNUIlMjJwYWRkaW5nX21hc2slMjIlNUQpJTBBYXVkaW9fdmFsdWVzJTIwJTNEJTIwbW9kZWwuZGVjb2RlKGVuY29kZXJfb3V0cHV0cy5hdWRpb19jb2RlcyUyQyUyMGVuY29kZXJfb3V0cHV0cy5hdWRpb19zY2FsZXMlMkMlMjBpbnB1dHMlNUIlMjJwYWRkaW5nX21hc2slMjIlNUQpJTVCMCU1RCUwQSUyMyUyMG9yJTIwdGhlJTIwZXF1aXZhbGVudCUyMHdpdGglMjBhJTIwZm9yd2FyZCUyMHBhc3MlMEFhdWRpb192YWx1ZXMlMjAlM0QlMjBtb2RlbChpbnB1dHMlNUIlMjJpbnB1dF92YWx1ZXMlMjIlNUQlMkMlMjBpbnB1dHMlNUIlMjJwYWRkaW5nX21hc2slMjIlNUQpLmF1ZGlvX3ZhbHVlcw==",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset, Audio
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> EncodecModel, AutoProcessor
<span class="hljs-meta">&gt;&gt;&gt; </span>librispeech_dummy = load_dataset(<span class="hljs-string">&quot;hf-internal-testing/librispeech_asr_dummy&quot;</span>, <span class="hljs-string">&quot;clean&quot;</span>, split=<span class="hljs-string">&quot;validation&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>model = EncodecModel.from_pretrained(<span class="hljs-string">&quot;facebook/encodec_24khz&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>processor = AutoProcessor.from_pretrained(<span class="hljs-string">&quot;facebook/encodec_24khz&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>librispeech_dummy = librispeech_dummy.cast_column(<span class="hljs-string">&quot;audio&quot;</span>, Audio(sampling_rate=processor.sampling_rate))
<span class="hljs-meta">&gt;&gt;&gt; </span>audio_sample = librispeech_dummy[-<span class="hljs-number">1</span>][<span class="hljs-string">&quot;audio&quot;</span>][<span class="hljs-string">&quot;array&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = processor(raw_audio=audio_sample, sampling_rate=processor.sampling_rate, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>encoder_outputs = model.encode(inputs[<span class="hljs-string">&quot;input_values&quot;</span>], inputs[<span class="hljs-string">&quot;padding_mask&quot;</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>audio_values = model.decode(encoder_outputs.audio_codes, encoder_outputs.audio_scales, inputs[<span class="hljs-string">&quot;padding_mask&quot;</span>])[<span class="hljs-number">0</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># or the equivalent with a forward pass</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>audio_values = model(inputs[<span class="hljs-string">&quot;input_values&quot;</span>], inputs[<span class="hljs-string">&quot;padding_mask&quot;</span>]).audio_values`,wrap:!1}}),Q=new be({props:{title:"EncodecConfig",local:"transformers.EncodecConfig",headingTag:"h2"}}),L=new ae({props:{name:"class transformers.EncodecConfig",anchor:"transformers.EncodecConfig",parameters:[{name:"target_bandwidths",val:" = [1.5, 3.0, 6.0, 12.0, 24.0]"},{name:"sampling_rate",val:" = 24000"},{name:"audio_channels",val:" = 1"},{name:"normalize",val:" = False"},{name:"chunk_length_s",val:" = None"},{name:"overlap",val:" = None"},{name:"hidden_size",val:" = 128"},{name:"num_filters",val:" = 32"},{name:"num_residual_layers",val:" = 1"},{name:"upsampling_ratios",val:" = [8, 5, 4, 2]"},{name:"norm_type",val:" = 'weight_norm'"},{name:"kernel_size",val:" = 7"},{name:"last_kernel_size",val:" = 7"},{name:"residual_kernel_size",val:" = 3"},{name:"dilation_growth_rate",val:" = 2"},{name:"use_causal_conv",val:" = True"},{name:"pad_mode",val:" = 'reflect'"},{name:"compress",val:" = 2"},{name:"num_lstm_layers",val:" = 2"},{name:"trim_right_ratio",val:" = 1.0"},{name:"codebook_size",val:" = 1024"},{name:"codebook_dim",val:" = None"},{name:"use_conv_shortcut",val:" = True"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.EncodecConfig.target_bandwidths",description:`<strong>target_bandwidths</strong> (<code>List[float]</code>, <em>optional</em>, defaults to <code>[1.5, 3.0, 6.0, 12.0, 24.0]</code>) &#x2014;
The range of diffent bandwiths the model can encode audio with.`,name:"target_bandwidths"},{anchor:"transformers.EncodecConfig.sampling_rate",description:`<strong>sampling_rate</strong> (<code>int</code>, <em>optional</em>, defaults to 24000) &#x2014;
The sampling rate at which the audio waveform should be digitalized expressed in hertz (Hz).`,name:"sampling_rate"},{anchor:"transformers.EncodecConfig.audio_channels",description:`<strong>audio_channels</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
Number of channels in the audio data. Either 1 for mono or 2 for stereo.`,name:"audio_channels"},{anchor:"transformers.EncodecConfig.normalize",description:`<strong>normalize</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the audio shall be normalized when passed.`,name:"normalize"},{anchor:"transformers.EncodecConfig.chunk_length_s",description:`<strong>chunk_length_s</strong> (<code>float</code>, <em>optional</em>) &#x2014;
If defined the audio is pre-processed into chunks of lengths <code>chunk_length_s</code> and then encoded.`,name:"chunk_length_s"},{anchor:"transformers.EncodecConfig.overlap",description:`<strong>overlap</strong> (<code>float</code>, <em>optional</em>) &#x2014;
Defines the overlap between each chunk. It is used to compute the <code>chunk_stride</code> using the following
formulae : <code>int((1.0 - self.overlap) * self.chunk_length)</code>.`,name:"overlap"},{anchor:"transformers.EncodecConfig.hidden_size",description:`<strong>hidden_size</strong> (<code>int</code>, <em>optional</em>, defaults to 128) &#x2014;
Intermediate representation dimension.`,name:"hidden_size"},{anchor:"transformers.EncodecConfig.num_filters",description:`<strong>num_filters</strong> (<code>int</code>, <em>optional</em>, defaults to 32) &#x2014;
Number of convolution kernels of first <code>EncodecConv1d</code> down sampling layer.`,name:"num_filters"},{anchor:"transformers.EncodecConfig.num_residual_layers",description:`<strong>num_residual_layers</strong> (<code>int</code>,  <em>optional</em>, defaults to 1) &#x2014;
Number of residual layers.`,name:"num_residual_layers"},{anchor:"transformers.EncodecConfig.upsampling_ratios",description:`<strong>upsampling_ratios</strong> (<code>Sequence[int]</code> , <em>optional</em>, defaults to <code>[8, 5, 4, 2]</code>) &#x2014;
Kernel size and stride ratios. The encoder uses downsampling ratios instead of upsampling ratios, hence it
will use the ratios in the reverse order to the ones specified here that must match the decoder order.`,name:"upsampling_ratios"},{anchor:"transformers.EncodecConfig.norm_type",description:`<strong>norm_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;weight_norm&quot;</code>) &#x2014;
Normalization method. Should be in <code>[&quot;weight_norm&quot;, &quot;time_group_norm&quot;]</code>`,name:"norm_type"},{anchor:"transformers.EncodecConfig.kernel_size",description:`<strong>kernel_size</strong> (<code>int</code>, <em>optional</em>, defaults to 7) &#x2014;
Kernel size for the initial convolution.`,name:"kernel_size"},{anchor:"transformers.EncodecConfig.last_kernel_size",description:`<strong>last_kernel_size</strong> (<code>int</code>, <em>optional</em>, defaults to 7) &#x2014;
Kernel size for the last convolution layer.`,name:"last_kernel_size"},{anchor:"transformers.EncodecConfig.residual_kernel_size",description:`<strong>residual_kernel_size</strong> (<code>int</code>, <em>optional</em>, defaults to 3) &#x2014;
Kernel size for the residual layers.`,name:"residual_kernel_size"},{anchor:"transformers.EncodecConfig.dilation_growth_rate",description:`<strong>dilation_growth_rate</strong> (<code>int</code>, <em>optional</em>, defaults to 2) &#x2014;
How much to increase the dilation with each layer.`,name:"dilation_growth_rate"},{anchor:"transformers.EncodecConfig.use_causal_conv",description:`<strong>use_causal_conv</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to use fully causal convolution.`,name:"use_causal_conv"},{anchor:"transformers.EncodecConfig.pad_mode",description:`<strong>pad_mode</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;reflect&quot;</code>) &#x2014;
Padding mode for the convolutions.`,name:"pad_mode"},{anchor:"transformers.EncodecConfig.compress",description:`<strong>compress</strong> (<code>int</code>, <em>optional</em>, defaults to 2) &#x2014;
Reduced dimensionality in residual branches (from Demucs v3).`,name:"compress"},{anchor:"transformers.EncodecConfig.num_lstm_layers",description:`<strong>num_lstm_layers</strong> (<code>int</code>, <em>optional</em>, defaults to 2) &#x2014;
Number of LSTM layers at the end of the encoder.`,name:"num_lstm_layers"},{anchor:"transformers.EncodecConfig.trim_right_ratio",description:`<strong>trim_right_ratio</strong> (<code>float</code>, <em>optional</em>, defaults to 1.0) &#x2014;
Ratio for trimming at the right of the transposed convolution under the <code>use_causal_conv = True</code> setup. If
equal to 1.0, it means that all the trimming is done at the right.`,name:"trim_right_ratio"},{anchor:"transformers.EncodecConfig.codebook_size",description:`<strong>codebook_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1024) &#x2014;
Number of discret codes that make up VQVAE.`,name:"codebook_size"},{anchor:"transformers.EncodecConfig.codebook_dim",description:`<strong>codebook_dim</strong> (<code>int</code>, <em>optional</em>) &#x2014;
Dimension of the codebook vectors. If not defined, uses <code>hidden_size</code>.`,name:"codebook_dim"},{anchor:"transformers.EncodecConfig.use_conv_shortcut",description:`<strong>use_conv_shortcut</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to use a convolutional layer as the &#x2018;skip&#x2019; connection in the <code>EncodecResnetBlock</code> block. If False,
an identity function will be used, giving a generic residual connection.`,name:"use_conv_shortcut"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/encodec/configuration_encodec.py#L35"}}),Z=new wt({props:{anchor:"transformers.EncodecConfig.example",$$slots:{default:[$t]},$$scope:{ctx:W}}}),S=new be({props:{title:"EncodecFeatureExtractor",local:"transformers.EncodecFeatureExtractor",headingTag:"h2"}}),D=new ae({props:{name:"class transformers.EncodecFeatureExtractor",anchor:"transformers.EncodecFeatureExtractor",parameters:[{name:"feature_size",val:": int = 1"},{name:"sampling_rate",val:": int = 24000"},{name:"padding_value",val:": float = 0.0"},{name:"chunk_length_s",val:": float = None"},{name:"overlap",val:": float = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.EncodecFeatureExtractor.feature_size",description:`<strong>feature_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
The feature dimension of the extracted features. Use 1 for mono, 2 for stereo.`,name:"feature_size"},{anchor:"transformers.EncodecFeatureExtractor.sampling_rate",description:`<strong>sampling_rate</strong> (<code>int</code>, <em>optional</em>, defaults to 24000) &#x2014;
The sampling rate at which the audio waveform should be digitalized expressed in hertz (Hz).`,name:"sampling_rate"},{anchor:"transformers.EncodecFeatureExtractor.padding_value",description:`<strong>padding_value</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The value that is used to fill the padding values.`,name:"padding_value"},{anchor:"transformers.EncodecFeatureExtractor.chunk_length_s",description:`<strong>chunk_length_s</strong> (<code>float</code>, <em>optional</em>) &#x2014;
If defined the audio is pre-processed into chunks of lengths <code>chunk_length_s</code> and then encoded.`,name:"chunk_length_s"},{anchor:"transformers.EncodecFeatureExtractor.overlap",description:`<strong>overlap</strong> (<code>float</code>, <em>optional</em>) &#x2014;
Defines the overlap between each chunk. It is used to compute the <code>chunk_stride</code> using the following
formulae : <code>int((1.0 - self.overlap) * self.chunk_length)</code>.`,name:"overlap"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/encodec/feature_extraction_encodec.py#L29"}}),A=new ae({props:{name:"__call__",anchor:"transformers.EncodecFeatureExtractor.__call__",parameters:[{name:"raw_audio",val:": Union"},{name:"padding",val:": Union = None"},{name:"truncation",val:": Optional = False"},{name:"max_length",val:": Optional = None"},{name:"return_tensors",val:": Union = None"},{name:"sampling_rate",val:": Optional = None"}],parametersDescription:[{anchor:"transformers.EncodecFeatureExtractor.__call__.raw_audio",description:`<strong>raw_audio</strong> (<code>np.ndarray</code>, <code>List[float]</code>, <code>List[np.ndarray]</code>, <code>List[List[float]]</code>) &#x2014;
The sequence or batch of sequences to be processed. Each sequence can be a numpy array, a list of float
values, a list of numpy arrays or a list of list of float values. The numpy array must be of shape
<code>(num_samples,)</code> for mono audio (<code>feature_size = 1</code>), or <code>(2, num_samples)</code> for stereo audio
(<code>feature_size = 2</code>).`,name:"raw_audio"},{anchor:"transformers.EncodecFeatureExtractor.__call__.padding",description:`<strong>padding</strong> (<code>bool</code>, <code>str</code> or <a href="/docs/transformers/main/en/internal/file_utils#transformers.utils.PaddingStrategy">PaddingStrategy</a>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Select a strategy to pad the returned sequences (according to the model&#x2019;s padding side and padding
index) among:</p>
<ul>
<li><code>True</code> or <code>&apos;longest&apos;</code>: Pad to the longest sequence in the batch (or no padding if only a single
sequence if provided).</li>
<li><code>&apos;max_length&apos;</code>: Pad to a maximum length specified with the argument <code>max_length</code> or to the maximum
acceptable input length for the model if that argument is not provided.</li>
<li><code>False</code> or <code>&apos;do_not_pad&apos;</code> (default): No padding (i.e., can output a batch with sequences of different
lengths).</li>
</ul>`,name:"padding"},{anchor:"transformers.EncodecFeatureExtractor.__call__.truncation",description:`<strong>truncation</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Activates truncation to cut input sequences longer than <code>max_length</code> to <code>max_length</code>.`,name:"truncation"},{anchor:"transformers.EncodecFeatureExtractor.__call__.max_length",description:`<strong>max_length</strong> (<code>int</code>, <em>optional</em>) &#x2014;
Maximum length of the returned list and optionally padding length (see above).`,name:"max_length"},{anchor:"transformers.EncodecFeatureExtractor.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>str</code> or <a href="/docs/transformers/main/en/internal/file_utils#transformers.TensorType">TensorType</a>, <em>optional</em>) &#x2014;
If set, will return tensors instead of list of python integers. Acceptable values are:</p>
<ul>
<li><code>&apos;tf&apos;</code>: Return TensorFlow <code>tf.constant</code> objects.</li>
<li><code>&apos;pt&apos;</code>: Return PyTorch <code>torch.Tensor</code> objects.</li>
<li><code>&apos;np&apos;</code>: Return Numpy <code>np.ndarray</code> objects.</li>
</ul>`,name:"return_tensors"},{anchor:"transformers.EncodecFeatureExtractor.__call__.sampling_rate",description:`<strong>sampling_rate</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The sampling rate at which the <code>audio</code> input was sampled. It is strongly recommended to pass
<code>sampling_rate</code> at the forward call to prevent silent errors.`,name:"sampling_rate"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/encodec/feature_extraction_encodec.py#L84"}}),O=new be({props:{title:"EncodecModel",local:"transformers.EncodecModel",headingTag:"h2"}}),K=new ae({props:{name:"class transformers.EncodecModel",anchor:"transformers.EncodecModel",parameters:[{name:"config",val:": EncodecConfig"}],parametersDescription:[{anchor:"transformers.EncodecModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/encodec#transformers.EncodecConfig">EncodecConfig</a>) &#x2014;
Model configuration class with all the parameters of the model. Initializing with a config file does not
load the weights associated with the model, only the configuration. Check out the
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/encodec/modeling_encodec.py#L526"}}),ee=new ae({props:{name:"decode",anchor:"transformers.EncodecModel.decode",parameters:[{name:"audio_codes",val:": Tensor"},{name:"audio_scales",val:": Tensor"},{name:"padding_mask",val:": Optional = None"},{name:"return_dict",val:": Optional = None"}],parametersDescription:[{anchor:"transformers.EncodecModel.decode.audio_codes",description:`<strong>audio_codes</strong> (<code>torch.FloatTensor</code>  of shape <code>(batch_size, nb_chunks, chunk_length)</code>, <em>optional</em>) &#x2014;
Discret code embeddings computed using <code>model.encode</code>.`,name:"audio_codes"},{anchor:"transformers.EncodecModel.decode.audio_scales",description:`<strong>audio_scales</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, nb_chunks)</code>, <em>optional</em>) &#x2014;
Scaling factor for each <code>audio_codes</code> input.`,name:"audio_scales"},{anchor:"transformers.EncodecModel.decode.padding_mask",description:`<strong>padding_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, channels, sequence_length)</code>) &#x2014;
Padding mask used to pad the <code>input_values</code>.`,name:"padding_mask"},{anchor:"transformers.EncodecModel.decode.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/encodec/modeling_encodec.py#L707"}}),te=new ae({props:{name:"encode",anchor:"transformers.EncodecModel.encode",parameters:[{name:"input_values",val:": Tensor"},{name:"padding_mask",val:": Tensor = None"},{name:"bandwidth",val:": Optional = None"},{name:"return_dict",val:": Optional = None"}],parametersDescription:[{anchor:"transformers.EncodecModel.encode.input_values",description:`<strong>input_values</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, channels, sequence_length)</code>) &#x2014;
Float values of the input audio waveform.`,name:"input_values"},{anchor:"transformers.EncodecModel.encode.padding_mask",description:`<strong>padding_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, channels, sequence_length)</code>) &#x2014;
Padding mask used to pad the <code>input_values</code>.`,name:"padding_mask"},{anchor:"transformers.EncodecModel.encode.bandwidth",description:`<strong>bandwidth</strong> (<code>float</code>, <em>optional</em>) &#x2014;
The target bandwidth. Must be one of <code>config.target_bandwidths</code>. If <code>None</code>, uses the smallest possible
bandwidth. bandwidth is represented as a thousandth of what it is, e.g. 6kbps bandwidth is represented
as bandwidth == 6.0`,name:"bandwidth"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/encodec/modeling_encodec.py#L579",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>A list of frames containing the discrete encoded codes for the input audio waveform, along with rescaling
factors for each chunk when <code>normalize</code> is True. Each frames is a tuple <code>(codebook, scale)</code>, with
<code>codebook</code> of shape <code>[batch_size, num_codebooks, frames]</code>.</p>
`}}),oe=new ae({props:{name:"forward",anchor:"transformers.EncodecModel.forward",parameters:[{name:"input_values",val:": Tensor"},{name:"padding_mask",val:": Optional = None"},{name:"bandwidth",val:": Optional = None"},{name:"audio_codes",val:": Optional = None"},{name:"audio_scales",val:": Optional = None"},{name:"return_dict",val:": Optional = None"}],parametersDescription:[{anchor:"transformers.EncodecModel.forward.input_values",description:`<strong>input_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, channels, sequence_length)</code>, <em>optional</em>) &#x2014;
Raw audio input converted to Float and padded to the approriate length in order to be encoded using chunks
of length self.chunk_length and a stride of <code>config.chunk_stride</code>.`,name:"input_values"},{anchor:"transformers.EncodecModel.forward.padding_mask",description:`<strong>padding_mask</strong> (<code>torch.BoolTensor</code> of shape <code>(batch_size, channels, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid computing scaling factors on padding token indices (can we avoid computing conv on these+).
Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<div class="course-tip course-tip-orange bg-gradient-to-br dark:bg-gradient-to-r before:border-orange-500 dark:before:border-orange-800 from-orange-50 dark:from-gray-900 to-white dark:to-gray-950 border border-orange-50 text-orange-700 dark:text-gray-400">
						
<p><code>padding_mask</code> should always be passed, unless the input was truncated or not padded. This is because in
order to process tensors effectively, the input audio should be padded so that <code>input_length % stride = step</code> with <code>step = chunk_length-stride</code>. This ensures that all chunks are of the same shape</p>

					</div>`,name:"padding_mask"},{anchor:"transformers.EncodecModel.forward.bandwidth",description:`<strong>bandwidth</strong> (<code>float</code>, <em>optional</em>) &#x2014;
The target bandwidth. Must be one of <code>config.target_bandwidths</code>. If <code>None</code>, uses the smallest possible
bandwidth. bandwidth is represented as a thousandth of what it is, e.g. 6kbps bandwidth is represented as
<code>bandwidth == 6.0</code>`,name:"bandwidth"},{anchor:"transformers.EncodecModel.forward.audio_codes",description:`<strong>audio_codes</strong> (<code>torch.FloatTensor</code>  of shape <code>(batch_size, nb_chunks, chunk_length)</code>, <em>optional</em>) &#x2014;
Discret code embeddings computed using <code>model.encode</code>.`,name:"audio_codes"},{anchor:"transformers.EncodecModel.forward.audio_scales",description:`<strong>audio_scales</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, nb_chunks)</code>, <em>optional</em>) &#x2014;
Scaling factor for each <code>audio_codes</code> input.`,name:"audio_scales"},{anchor:"transformers.EncodecModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/encodec/modeling_encodec.py#L755",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>A <code>transformers.models.encodec.modeling_encodec.EncodecOutput</code> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/encodec#transformers.EncodecConfig"
>EncodecConfig</a>) and inputs.</p>
<ul>
<li><strong>audio_codes</strong> (<code>torch.FloatTensor</code>  of shape <code>(batch_size, nb_chunks, chunk_length)</code>, <em>optional</em>) â Discret code embeddings computed using <code>model.encode</code>.</li>
<li><strong>audio_values</strong> (<code>torch.FlaotTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>)
Decoded audio values, obtained using the decoder part of Encodec.</li>
</ul>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>transformers.models.encodec.modeling_encodec.EncodecOutput</code> or <code>tuple(torch.FloatTensor)</code></p>
`}}),F=new Tt({props:{$$slots:{default:[jt]},$$scope:{ctx:W}}}),R=new wt({props:{anchor:"transformers.EncodecModel.forward.example",$$slots:{default:[Ct]},$$scope:{ctx:W}}}),{c(){c=i("meta"),E=n(),p=i("p"),m=n(),h(w.$$.fragment),r=n(),h(M.$$.fragment),we=n(),q=i("p"),q.innerHTML=nt,ye=n(),B=i("p"),B.textContent=at,Me=n(),X=i("p"),X.innerHTML=st,ke=n(),G=i("p"),G.innerHTML=rt,Ee=n(),h(H.$$.fragment),xe=n(),P=i("p"),P.textContent=ct,Te=n(),h(Y.$$.fragment),$e=n(),h(Q.$$.fragment),je=n(),x=i("div"),h(L.$$.fragment),Ie=n(),se=i("p"),se.innerHTML=dt,Fe=n(),re=i("p"),re.innerHTML=it,Re=n(),h(Z.$$.fragment),Ce=n(),h(S.$$.fragment),Je=n(),k=i("div"),h(D.$$.fragment),Ve=n(),ce=i("p"),ce.textContent=lt,qe=n(),de=i("p"),de.innerHTML=mt,Be=n(),ie=i("p"),ie.innerHTML=pt,Xe=n(),N=i("div"),h(A.$$.fragment),Ge=n(),le=i("p"),le.textContent=ut,ze=n(),h(O.$$.fragment),Ue=n(),y=i("div"),h(K.$$.fragment),He=n(),me=i("p"),me.innerHTML=ht,Pe=n(),pe=i("p"),pe.innerHTML=ft,Ye=n(),J=i("div"),h(ee.$$.fragment),Qe=n(),ue=i("p"),ue.textContent=gt,Le=n(),he=i("p"),he.textContent=_t,Se=n(),I=i("div"),h(te.$$.fragment),De=n(),fe=i("p"),fe.textContent=bt,Ae=n(),$=i("div"),h(oe.$$.fragment),Oe=n(),ge=i("p"),ge.innerHTML=vt,Ke=n(),h(F.$$.fragment),et=n(),h(R.$$.fragment),We=n(),ve=i("p"),this.h()},l(e){const t=xt("svelte-u9bgzb",document.head);c=l(t,"META",{name:!0,content:!0}),t.forEach(o),E=a(e),p=l(e,"P",{}),z(p).forEach(o),m=a(e),f(w.$$.fragment,e),r=a(e),f(M.$$.fragment,e),we=a(e),q=l(e,"P",{"data-svelte-h":!0}),u(q)!=="svelte-12eaz08"&&(q.innerHTML=nt),ye=a(e),B=l(e,"P",{"data-svelte-h":!0}),u(B)!=="svelte-vfdo9a"&&(B.textContent=at),Me=a(e),X=l(e,"P",{"data-svelte-h":!0}),u(X)!=="svelte-1hdoj6v"&&(X.innerHTML=st),ke=a(e),G=l(e,"P",{"data-svelte-h":!0}),u(G)!=="svelte-1gknafi"&&(G.innerHTML=rt),Ee=a(e),f(H.$$.fragment,e),xe=a(e),P=l(e,"P",{"data-svelte-h":!0}),u(P)!=="svelte-b4kgu7"&&(P.textContent=ct),Te=a(e),f(Y.$$.fragment,e),$e=a(e),f(Q.$$.fragment,e),je=a(e),x=l(e,"DIV",{class:!0});var C=z(x);f(L.$$.fragment,C),Ie=a(C),se=l(C,"P",{"data-svelte-h":!0}),u(se)!=="svelte-r5mojf"&&(se.innerHTML=dt),Fe=a(C),re=l(C,"P",{"data-svelte-h":!0}),u(re)!=="svelte-o55m63"&&(re.innerHTML=it),Re=a(C),f(Z.$$.fragment,C),C.forEach(o),Ce=a(e),f(S.$$.fragment,e),Je=a(e),k=l(e,"DIV",{class:!0});var T=z(k);f(D.$$.fragment,T),Ve=a(T),ce=l(T,"P",{"data-svelte-h":!0}),u(ce)!=="svelte-5n3zz2"&&(ce.textContent=lt),qe=a(T),de=l(T,"P",{"data-svelte-h":!0}),u(de)!=="svelte-3gz575"&&(de.innerHTML=mt),Be=a(T),ie=l(T,"P",{"data-svelte-h":!0}),u(ie)!=="svelte-7r1z10"&&(ie.innerHTML=pt),Xe=a(T),N=l(T,"DIV",{class:!0});var ne=z(N);f(A.$$.fragment,ne),Ge=a(ne),le=l(ne,"P",{"data-svelte-h":!0}),u(le)!=="svelte-1a6wgfx"&&(le.textContent=ut),ne.forEach(o),T.forEach(o),ze=a(e),f(O.$$.fragment,e),Ue=a(e),y=l(e,"DIV",{class:!0});var j=z(y);f(K.$$.fragment,j),He=a(j),me=l(j,"P",{"data-svelte-h":!0}),u(me)!=="svelte-172v7wq"&&(me.innerHTML=ht),Pe=a(j),pe=l(j,"P",{"data-svelte-h":!0}),u(pe)!=="svelte-hswkmf"&&(pe.innerHTML=ft),Ye=a(j),J=l(j,"DIV",{class:!0});var _e=z(J);f(ee.$$.fragment,_e),Qe=a(_e),ue=l(_e,"P",{"data-svelte-h":!0}),u(ue)!=="svelte-18b2f30"&&(ue.textContent=gt),Le=a(_e),he=l(_e,"P",{"data-svelte-h":!0}),u(he)!=="svelte-12sn3fy"&&(he.textContent=_t),_e.forEach(o),Se=a(j),I=l(j,"DIV",{class:!0});var Ne=z(I);f(te.$$.fragment,Ne),De=a(Ne),fe=l(Ne,"P",{"data-svelte-h":!0}),u(fe)!=="svelte-1mhlb4g"&&(fe.textContent=bt),Ne.forEach(o),Ae=a(j),$=l(j,"DIV",{class:!0});var V=z($);f(oe.$$.fragment,V),Oe=a(V),ge=l(V,"P",{"data-svelte-h":!0}),u(ge)!=="svelte-91m5tw"&&(ge.innerHTML=vt),Ke=a(V),f(F.$$.fragment,V),et=a(V),f(R.$$.fragment,V),V.forEach(o),j.forEach(o),We=a(e),ve=l(e,"P",{}),z(ve).forEach(o),this.h()},h(){U(c,"name","hf:doc:metadata"),U(c,"content",zt),U(x,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),U(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),U(k,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),U(J,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),U(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),U($,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),U(y,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(e,t){s(document.head,c),d(e,E,t),d(e,p,t),d(e,m,t),g(w,e,t),d(e,r,t),g(M,e,t),d(e,we,t),d(e,q,t),d(e,ye,t),d(e,B,t),d(e,Me,t),d(e,X,t),d(e,ke,t),d(e,G,t),d(e,Ee,t),g(H,e,t),d(e,xe,t),d(e,P,t),d(e,Te,t),g(Y,e,t),d(e,$e,t),g(Q,e,t),d(e,je,t),d(e,x,t),g(L,x,null),s(x,Ie),s(x,se),s(x,Fe),s(x,re),s(x,Re),g(Z,x,null),d(e,Ce,t),g(S,e,t),d(e,Je,t),d(e,k,t),g(D,k,null),s(k,Ve),s(k,ce),s(k,qe),s(k,de),s(k,Be),s(k,ie),s(k,Xe),s(k,N),g(A,N,null),s(N,Ge),s(N,le),d(e,ze,t),g(O,e,t),d(e,Ue,t),d(e,y,t),g(K,y,null),s(y,He),s(y,me),s(y,Pe),s(y,pe),s(y,Ye),s(y,J),g(ee,J,null),s(J,Qe),s(J,ue),s(J,Le),s(J,he),s(y,Se),s(y,I),g(te,I,null),s(I,De),s(I,fe),s(y,Ae),s(y,$),g(oe,$,null),s($,Oe),s($,ge),s($,Ke),g(F,$,null),s($,et),g(R,$,null),d(e,We,t),d(e,ve,t),Ze=!0},p(e,[t]){const C={};t&2&&(C.$$scope={dirty:t,ctx:e}),Z.$set(C);const T={};t&2&&(T.$$scope={dirty:t,ctx:e}),F.$set(T);const ne={};t&2&&(ne.$$scope={dirty:t,ctx:e}),R.$set(ne)},i(e){Ze||(_(w.$$.fragment,e),_(M.$$.fragment,e),_(H.$$.fragment,e),_(Y.$$.fragment,e),_(Q.$$.fragment,e),_(L.$$.fragment,e),_(Z.$$.fragment,e),_(S.$$.fragment,e),_(D.$$.fragment,e),_(A.$$.fragment,e),_(O.$$.fragment,e),_(K.$$.fragment,e),_(ee.$$.fragment,e),_(te.$$.fragment,e),_(oe.$$.fragment,e),_(F.$$.fragment,e),_(R.$$.fragment,e),Ze=!0)},o(e){b(w.$$.fragment,e),b(M.$$.fragment,e),b(H.$$.fragment,e),b(Y.$$.fragment,e),b(Q.$$.fragment,e),b(L.$$.fragment,e),b(Z.$$.fragment,e),b(S.$$.fragment,e),b(D.$$.fragment,e),b(A.$$.fragment,e),b(O.$$.fragment,e),b(K.$$.fragment,e),b(ee.$$.fragment,e),b(te.$$.fragment,e),b(oe.$$.fragment,e),b(F.$$.fragment,e),b(R.$$.fragment,e),Ze=!1},d(e){e&&(o(E),o(p),o(m),o(r),o(we),o(q),o(ye),o(B),o(Me),o(X),o(ke),o(G),o(Ee),o(xe),o(P),o(Te),o($e),o(je),o(x),o(Ce),o(Je),o(k),o(ze),o(Ue),o(y),o(We),o(ve)),o(c),v(w,e),v(M,e),v(H,e),v(Y,e),v(Q,e),v(L),v(Z),v(S,e),v(D),v(A),v(O,e),v(K),v(ee),v(te),v(oe),v(F),v(R)}}}const zt='{"title":"EnCodec","local":"encodec","sections":[{"title":"Overview","local":"overview","sections":[],"depth":2},{"title":"Usage example","local":"usage-example","sections":[],"depth":2},{"title":"EncodecConfig","local":"transformers.EncodecConfig","sections":[],"depth":2},{"title":"EncodecFeatureExtractor","local":"transformers.EncodecFeatureExtractor","sections":[],"depth":2},{"title":"EncodecModel","local":"transformers.EncodecModel","sections":[],"depth":2}],"depth":1}';function Ut(W){return Mt(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class qt extends kt{constructor(c){super(),Et(this,c,Ut,Jt,yt,{})}}export{qt as component};
