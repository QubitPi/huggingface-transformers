import{s as ke,o as Ge,n as he}from"../chunks/scheduler.9bc65507.js";import{S as ze,i as Be,g,s as l,r as b,A as Ve,h as f,f as r,c as i,j as ie,u as y,x,k as de,y as d,a as m,v as $,d as w,t as M,w as T}from"../chunks/index.707bf1b6.js";import{T as Je}from"../chunks/Tip.c2ecdbf4.js";import{D as fe}from"../chunks/Docstring.17db21ae.js";import{C as Re}from"../chunks/CodeBlock.54a9f38d.js";import{F as Pe,M as We}from"../chunks/Markdown.fef84341.js";import{E as Fe}from"../chunks/ExampleCodeBlock.4f515aa9.js";import{P as He}from"../chunks/PipelineTag.44585822.js";import{H as Te}from"../chunks/Heading.342b1fa6.js";function Le(F){let e,c="Example:",t,n,p;return n=new Re({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFJlZ05ldENvbmZpZyUyQyUyMFJlZ05ldE1vZGVsJTBBJTBBJTIzJTIwSW5pdGlhbGl6aW5nJTIwYSUyMFJlZ05ldCUyMHJlZ25ldC15LTQwJTIwc3R5bGUlMjBjb25maWd1cmF0aW9uJTBBY29uZmlndXJhdGlvbiUyMCUzRCUyMFJlZ05ldENvbmZpZygpJTBBJTIzJTIwSW5pdGlhbGl6aW5nJTIwYSUyMG1vZGVsJTIwZnJvbSUyMHRoZSUyMHJlZ25ldC15LTQwJTIwc3R5bGUlMjBjb25maWd1cmF0aW9uJTBBbW9kZWwlMjAlM0QlMjBSZWdOZXRNb2RlbChjb25maWd1cmF0aW9uKSUwQSUyMyUyMEFjY2Vzc2luZyUyMHRoZSUyMG1vZGVsJTIwY29uZmlndXJhdGlvbiUwQWNvbmZpZ3VyYXRpb24lMjAlM0QlMjBtb2RlbC5jb25maWc=",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> RegNetConfig, RegNetModel

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a RegNet regnet-y-40 style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = RegNetConfig()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a model from the regnet-y-40 style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = RegNetModel(configuration)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Accessing the model configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = model.config`,wrap:!1}}),{c(){e=g("p"),e.textContent=c,t=l(),b(n.$$.fragment)},l(s){e=f(s,"P",{"data-svelte-h":!0}),x(e)!=="svelte-11lpom8"&&(e.textContent=c),t=i(s),y(n.$$.fragment,s)},m(s,j){m(s,e,j),m(s,t,j),$(n,s,j),p=!0},p:he,i(s){p||(w(n.$$.fragment,s),p=!0)},o(s){M(n.$$.fragment,s),p=!1},d(s){s&&(r(e),r(t)),T(n,s)}}}function Ee(F){let e,c=`Although the recipe for forward pass needs to be defined within this function, one should call the <code>Module</code>
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`;return{c(){e=g("p"),e.innerHTML=c},l(t){e=f(t,"P",{"data-svelte-h":!0}),x(e)!=="svelte-fincs2"&&(e.innerHTML=c)},m(t,n){m(t,e,n)},p:he,d(t){t&&r(e)}}}function Qe(F){let e,c="Example:",t,n,p;return n=new Re({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9JbWFnZVByb2Nlc3NvciUyQyUyMFJlZ05ldE1vZGVsJTBBaW1wb3J0JTIwdG9yY2glMEFmcm9tJTIwZGF0YXNldHMlMjBpbXBvcnQlMjBsb2FkX2RhdGFzZXQlMEElMEFkYXRhc2V0JTIwJTNEJTIwbG9hZF9kYXRhc2V0KCUyMmh1Z2dpbmdmYWNlJTJGY2F0cy1pbWFnZSUyMiklMEFpbWFnZSUyMCUzRCUyMGRhdGFzZXQlNUIlMjJ0ZXN0JTIyJTVEJTVCJTIyaW1hZ2UlMjIlNUQlNUIwJTVEJTBBJTBBaW1hZ2VfcHJvY2Vzc29yJTIwJTNEJTIwQXV0b0ltYWdlUHJvY2Vzc29yLmZyb21fcHJldHJhaW5lZCglMjJmYWNlYm9vayUyRnJlZ25ldC15LTA0MCUyMiklMEFtb2RlbCUyMCUzRCUyMFJlZ05ldE1vZGVsLmZyb21fcHJldHJhaW5lZCglMjJmYWNlYm9vayUyRnJlZ25ldC15LTA0MCUyMiklMEElMEFpbnB1dHMlMjAlM0QlMjBpbWFnZV9wcm9jZXNzb3IoaW1hZ2UlMkMlMjByZXR1cm5fdGVuc29ycyUzRCUyMnB0JTIyKSUwQSUwQXdpdGglMjB0b3JjaC5ub19ncmFkKCklM0ElMEElMjAlMjAlMjAlMjBvdXRwdXRzJTIwJTNEJTIwbW9kZWwoKippbnB1dHMpJTBBJTBBbGFzdF9oaWRkZW5fc3RhdGVzJTIwJTNEJTIwb3V0cHV0cy5sYXN0X2hpZGRlbl9zdGF0ZSUwQWxpc3QobGFzdF9oaWRkZW5fc3RhdGVzLnNoYXBlKQ==",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoImageProcessor, RegNetModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;huggingface/cats-image&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>image = dataset[<span class="hljs-string">&quot;test&quot;</span>][<span class="hljs-string">&quot;image&quot;</span>][<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>image_processor = AutoImageProcessor.from_pretrained(<span class="hljs-string">&quot;facebook/regnet-y-040&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = RegNetModel.from_pretrained(<span class="hljs-string">&quot;facebook/regnet-y-040&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = image_processor(image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(last_hidden_states.shape)
[<span class="hljs-number">1</span>, <span class="hljs-number">1088</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>]`,wrap:!1}}),{c(){e=g("p"),e.textContent=c,t=l(),b(n.$$.fragment)},l(s){e=f(s,"P",{"data-svelte-h":!0}),x(e)!=="svelte-11lpom8"&&(e.textContent=c),t=i(s),y(n.$$.fragment,s)},m(s,j){m(s,e,j),m(s,t,j),$(n,s,j),p=!0},p:he,i(s){p||(w(n.$$.fragment,s),p=!0)},o(s){M(n.$$.fragment,s),p=!1},d(s){s&&(r(e),r(t)),T(n,s)}}}function Xe(F){let e,c=`Although the recipe for forward pass needs to be defined within this function, one should call the <code>Module</code>
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`;return{c(){e=g("p"),e.innerHTML=c},l(t){e=f(t,"P",{"data-svelte-h":!0}),x(e)!=="svelte-fincs2"&&(e.innerHTML=c)},m(t,n){m(t,e,n)},p:he,d(t){t&&r(e)}}}function Ye(F){let e,c="Example:",t,n,p;return n=new Re({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9JbWFnZVByb2Nlc3NvciUyQyUyMFJlZ05ldEZvckltYWdlQ2xhc3NpZmljYXRpb24lMEFpbXBvcnQlMjB0b3JjaCUwQWZyb20lMjBkYXRhc2V0cyUyMGltcG9ydCUyMGxvYWRfZGF0YXNldCUwQSUwQWRhdGFzZXQlMjAlM0QlMjBsb2FkX2RhdGFzZXQoJTIyaHVnZ2luZ2ZhY2UlMkZjYXRzLWltYWdlJTIyKSUwQWltYWdlJTIwJTNEJTIwZGF0YXNldCU1QiUyMnRlc3QlMjIlNUQlNUIlMjJpbWFnZSUyMiU1RCU1QjAlNUQlMEElMEFpbWFnZV9wcm9jZXNzb3IlMjAlM0QlMjBBdXRvSW1hZ2VQcm9jZXNzb3IuZnJvbV9wcmV0cmFpbmVkKCUyMmZhY2Vib29rJTJGcmVnbmV0LXktMDQwJTIyKSUwQW1vZGVsJTIwJTNEJTIwUmVnTmV0Rm9ySW1hZ2VDbGFzc2lmaWNhdGlvbi5mcm9tX3ByZXRyYWluZWQoJTIyZmFjZWJvb2slMkZyZWduZXQteS0wNDAlMjIpJTBBJTBBaW5wdXRzJTIwJTNEJTIwaW1hZ2VfcHJvY2Vzc29yKGltYWdlJTJDJTIwcmV0dXJuX3RlbnNvcnMlM0QlMjJwdCUyMiklMEElMEF3aXRoJTIwdG9yY2gubm9fZ3JhZCgpJTNBJTBBJTIwJTIwJTIwJTIwbG9naXRzJTIwJTNEJTIwbW9kZWwoKippbnB1dHMpLmxvZ2l0cyUwQSUwQSUyMyUyMG1vZGVsJTIwcHJlZGljdHMlMjBvbmUlMjBvZiUyMHRoZSUyMDEwMDAlMjBJbWFnZU5ldCUyMGNsYXNzZXMlMEFwcmVkaWN0ZWRfbGFiZWwlMjAlM0QlMjBsb2dpdHMuYXJnbWF4KC0xKS5pdGVtKCklMEFwcmludChtb2RlbC5jb25maWcuaWQybGFiZWwlNUJwcmVkaWN0ZWRfbGFiZWwlNUQp",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoImageProcessor, RegNetForImageClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;huggingface/cats-image&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>image = dataset[<span class="hljs-string">&quot;test&quot;</span>][<span class="hljs-string">&quot;image&quot;</span>][<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>image_processor = AutoImageProcessor.from_pretrained(<span class="hljs-string">&quot;facebook/regnet-y-040&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = RegNetForImageClassification.from_pretrained(<span class="hljs-string">&quot;facebook/regnet-y-040&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = image_processor(image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># model predicts one of the 1000 ImageNet classes</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_label = logits.argmax(-<span class="hljs-number">1</span>).item()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(model.config.id2label[predicted_label])
tabby, tabby cat`,wrap:!1}}),{c(){e=g("p"),e.textContent=c,t=l(),b(n.$$.fragment)},l(s){e=f(s,"P",{"data-svelte-h":!0}),x(e)!=="svelte-11lpom8"&&(e.textContent=c),t=i(s),y(n.$$.fragment,s)},m(s,j){m(s,e,j),m(s,t,j),$(n,s,j),p=!0},p:he,i(s){p||(w(n.$$.fragment,s),p=!0)},o(s){M(n.$$.fragment,s),p=!1},d(s){s&&(r(e),r(t)),T(n,s)}}}function qe(F){let e,c,t,n,p,s,j=`The bare RegNet model outputting raw features without any specific head on top.
This model is a PyTorch <a href="https://pytorch.org/docs/stable/nn.html#torch.nn.Module" rel="nofollow">torch.nn.Module</a> subclass. Use it
as a regular PyTorch Module and refer to the PyTorch documentation for all matters related to general usage and
behavior.`,ne,C,X,ae,z,be='The <a href="/docs/transformers/main/en/model_doc/regnet#transformers.RegNetModel">RegNetModel</a> forward method, overrides the <code>__call__</code> special method.',oe,Z,pe,P,L,Y,ee,u,H,re,B,ye=`RegNet Model with an image classification head on top (a linear layer on top of the pooled features), e.g. for
ImageNet.`,le,k,ce=`This model is a PyTorch <a href="https://pytorch.org/docs/stable/nn.html#torch.nn.Module" rel="nofollow">torch.nn.Module</a> subclass. Use it
as a regular PyTorch Module and refer to the PyTorch documentation for all matters related to general usage and
behavior.`,E,U,V,D,R,q='The <a href="/docs/transformers/main/en/model_doc/regnet#transformers.RegNetForImageClassification">RegNetForImageClassification</a> forward method, overrides the <code>__call__</code> special method.',me,G,te,Q,S;return e=new Te({props:{title:"RegNetModel",local:"transformers.RegNetModel",headingTag:"h2"}}),n=new fe({props:{name:"class transformers.RegNetModel",anchor:"transformers.RegNetModel",parameters:[{name:"config",val:""}],parametersDescription:[{anchor:"transformers.RegNetModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/regnet#transformers.RegNetConfig">RegNetConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/regnet/modeling_regnet.py#L321"}}),X=new fe({props:{name:"forward",anchor:"transformers.RegNetModel.forward",parameters:[{name:"pixel_values",val:": Tensor"},{name:"output_hidden_states",val:": Optional = None"},{name:"return_dict",val:": Optional = None"}],parametersDescription:[{anchor:"transformers.RegNetModel.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Pixel values can be obtained using <a href="/docs/transformers/main/en/model_doc/auto#transformers.AutoImageProcessor">AutoImageProcessor</a>. See
<a href="/docs/transformers/main/en/model_doc/layoutlmv2#transformers.LayoutLMv2FeatureExtractor.__call__">ConvNextImageProcessor.<strong>call</strong>()</a> for details.`,name:"pixel_values"},{anchor:"transformers.RegNetModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.RegNetModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/regnet/modeling_regnet.py#L336",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>A <code>transformers.modeling_outputs.BaseModelOutputWithPoolingAndNoAttention</code> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/regnet#transformers.RegNetConfig"
>RegNetConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) — Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>pooler_output</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, hidden_size)</code>) — Last layer hidden-state after a pooling operation on the spatial dimensions.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) — Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, num_channels, height, width)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
</ul>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>transformers.modeling_outputs.BaseModelOutputWithPoolingAndNoAttention</code> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Z=new Je({props:{$$slots:{default:[Ee]},$$scope:{ctx:F}}}),P=new Fe({props:{anchor:"transformers.RegNetModel.forward.example",$$slots:{default:[Qe]},$$scope:{ctx:F}}}),Y=new Te({props:{title:"RegNetForImageClassification",local:"transformers.RegNetForImageClassification",headingTag:"h2"}}),H=new fe({props:{name:"class transformers.RegNetForImageClassification",anchor:"transformers.RegNetForImageClassification",parameters:[{name:"config",val:""}],parametersDescription:[{anchor:"transformers.RegNetForImageClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/regnet#transformers.RegNetConfig">RegNetConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/regnet/modeling_regnet.py#L372"}}),V=new fe({props:{name:"forward",anchor:"transformers.RegNetForImageClassification.forward",parameters:[{name:"pixel_values",val:": Optional = None"},{name:"labels",val:": Optional = None"},{name:"output_hidden_states",val:": Optional = None"},{name:"return_dict",val:": Optional = None"}],parametersDescription:[{anchor:"transformers.RegNetForImageClassification.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Pixel values can be obtained using <a href="/docs/transformers/main/en/model_doc/auto#transformers.AutoImageProcessor">AutoImageProcessor</a>. See
<a href="/docs/transformers/main/en/model_doc/layoutlmv2#transformers.LayoutLMv2FeatureExtractor.__call__">ConvNextImageProcessor.<strong>call</strong>()</a> for details.`,name:"pixel_values"},{anchor:"transformers.RegNetForImageClassification.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.RegNetForImageClassification.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.RegNetForImageClassification.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the image classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/regnet/modeling_regnet.py#L393",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.ImageClassifierOutputWithNoAttention"
>transformers.modeling_outputs.ImageClassifierOutputWithNoAttention</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/regnet#transformers.RegNetConfig"
>RegNetConfig</a>) and inputs.</p>
<ul>
<li><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) — Classification (or regression if config.num_labels==1) loss.</li>
<li><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.num_labels)</code>) — Classification (or regression if config.num_labels==1) scores (before SoftMax).</li>
<li><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) — Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each stage) of shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also
called feature maps) of the model at the output of each stage.</li>
</ul>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_outputs.ImageClassifierOutputWithNoAttention"
>transformers.modeling_outputs.ImageClassifierOutputWithNoAttention</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),G=new Je({props:{$$slots:{default:[Xe]},$$scope:{ctx:F}}}),Q=new Fe({props:{anchor:"transformers.RegNetForImageClassification.forward.example",$$slots:{default:[Ye]},$$scope:{ctx:F}}}),{c(){b(e.$$.fragment),c=l(),t=g("div"),b(n.$$.fragment),p=l(),s=g("p"),s.innerHTML=j,ne=l(),C=g("div"),b(X.$$.fragment),ae=l(),z=g("p"),z.innerHTML=be,oe=l(),b(Z.$$.fragment),pe=l(),b(P.$$.fragment),L=l(),b(Y.$$.fragment),ee=l(),u=g("div"),b(H.$$.fragment),re=l(),B=g("p"),B.textContent=ye,le=l(),k=g("p"),k.innerHTML=ce,E=l(),U=g("div"),b(V.$$.fragment),D=l(),R=g("p"),R.innerHTML=q,me=l(),b(G.$$.fragment),te=l(),b(Q.$$.fragment),this.h()},l(o){y(e.$$.fragment,o),c=i(o),t=f(o,"DIV",{class:!0});var h=ie(t);y(n.$$.fragment,h),p=i(h),s=f(h,"P",{"data-svelte-h":!0}),x(s)!=="svelte-8ru9mu"&&(s.innerHTML=j),ne=i(h),C=f(h,"DIV",{class:!0});var N=ie(C);y(X.$$.fragment,N),ae=i(N),z=f(N,"P",{"data-svelte-h":!0}),x(z)!=="svelte-7oyxd8"&&(z.innerHTML=be),oe=i(N),y(Z.$$.fragment,N),pe=i(N),y(P.$$.fragment,N),N.forEach(r),h.forEach(r),L=i(o),y(Y.$$.fragment,o),ee=i(o),u=f(o,"DIV",{class:!0});var J=ie(u);y(H.$$.fragment,J),re=i(J),B=f(J,"P",{"data-svelte-h":!0}),x(B)!=="svelte-ipsb0r"&&(B.textContent=ye),le=i(J),k=f(J,"P",{"data-svelte-h":!0}),x(k)!=="svelte-1in5o75"&&(k.innerHTML=ce),E=i(J),U=f(J,"DIV",{class:!0});var W=ie(U);y(V.$$.fragment,W),D=i(W),R=f(W,"P",{"data-svelte-h":!0}),x(R)!=="svelte-idxxuu"&&(R.innerHTML=q),me=i(W),y(G.$$.fragment,W),te=i(W),y(Q.$$.fragment,W),W.forEach(r),J.forEach(r),this.h()},h(){de(C,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),de(t,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),de(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),de(u,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(o,h){$(e,o,h),m(o,c,h),m(o,t,h),$(n,t,null),d(t,p),d(t,s),d(t,ne),d(t,C),$(X,C,null),d(C,ae),d(C,z),d(C,oe),$(Z,C,null),d(C,pe),$(P,C,null),m(o,L,h),$(Y,o,h),m(o,ee,h),m(o,u,h),$(H,u,null),d(u,re),d(u,B),d(u,le),d(u,k),d(u,E),d(u,U),$(V,U,null),d(U,D),d(U,R),d(U,me),$(G,U,null),d(U,te),$(Q,U,null),S=!0},p(o,h){const N={};h&2&&(N.$$scope={dirty:h,ctx:o}),Z.$set(N);const J={};h&2&&(J.$$scope={dirty:h,ctx:o}),P.$set(J);const W={};h&2&&(W.$$scope={dirty:h,ctx:o}),G.$set(W);const K={};h&2&&(K.$$scope={dirty:h,ctx:o}),Q.$set(K)},i(o){S||(w(e.$$.fragment,o),w(n.$$.fragment,o),w(X.$$.fragment,o),w(Z.$$.fragment,o),w(P.$$.fragment,o),w(Y.$$.fragment,o),w(H.$$.fragment,o),w(V.$$.fragment,o),w(G.$$.fragment,o),w(Q.$$.fragment,o),S=!0)},o(o){M(e.$$.fragment,o),M(n.$$.fragment,o),M(X.$$.fragment,o),M(Z.$$.fragment,o),M(P.$$.fragment,o),M(Y.$$.fragment,o),M(H.$$.fragment,o),M(V.$$.fragment,o),M(G.$$.fragment,o),M(Q.$$.fragment,o),S=!1},d(o){o&&(r(c),r(t),r(L),r(ee),r(u)),T(e,o),T(n),T(X),T(Z),T(P),T(Y,o),T(H),T(V),T(G),T(Q)}}}function Se(F){let e,c;return e=new We({props:{$$slots:{default:[qe]},$$scope:{ctx:F}}}),{c(){b(e.$$.fragment)},l(t){y(e.$$.fragment,t)},m(t,n){$(e,t,n),c=!0},p(t,n){const p={};n&2&&(p.$$scope={dirty:n,ctx:t}),e.$set(p)},i(t){c||(w(e.$$.fragment,t),c=!0)},o(t){M(e.$$.fragment,t),c=!1},d(t){T(e,t)}}}function Ae(F){let e,c=`Although the recipe for forward pass needs to be defined within this function, one should call the <code>Module</code>
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`;return{c(){e=g("p"),e.innerHTML=c},l(t){e=f(t,"P",{"data-svelte-h":!0}),x(e)!=="svelte-fincs2"&&(e.innerHTML=c)},m(t,n){m(t,e,n)},p:he,d(t){t&&r(e)}}}function De(F){let e,c="Example:",t,n,p;return n=new Re({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9JbWFnZVByb2Nlc3NvciUyQyUyMFRGUmVnTmV0TW9kZWwlMEFmcm9tJTIwZGF0YXNldHMlMjBpbXBvcnQlMjBsb2FkX2RhdGFzZXQlMEElMEFkYXRhc2V0JTIwJTNEJTIwbG9hZF9kYXRhc2V0KCUyMmh1Z2dpbmdmYWNlJTJGY2F0cy1pbWFnZSUyMiklMEFpbWFnZSUyMCUzRCUyMGRhdGFzZXQlNUIlMjJ0ZXN0JTIyJTVEJTVCJTIyaW1hZ2UlMjIlNUQlNUIwJTVEJTBBJTBBaW1hZ2VfcHJvY2Vzc29yJTIwJTNEJTIwQXV0b0ltYWdlUHJvY2Vzc29yLmZyb21fcHJldHJhaW5lZCglMjJmYWNlYm9vayUyRnJlZ25ldC15LTA0MCUyMiklMEFtb2RlbCUyMCUzRCUyMFRGUmVnTmV0TW9kZWwuZnJvbV9wcmV0cmFpbmVkKCUyMmZhY2Vib29rJTJGcmVnbmV0LXktMDQwJTIyKSUwQSUwQWlucHV0cyUyMCUzRCUyMGltYWdlX3Byb2Nlc3NvcihpbWFnZSUyQyUyMHJldHVybl90ZW5zb3JzJTNEJTIydGYlMjIpJTBBb3V0cHV0cyUyMCUzRCUyMG1vZGVsKCoqaW5wdXRzKSUwQSUwQWxhc3RfaGlkZGVuX3N0YXRlcyUyMCUzRCUyMG91dHB1dHMubGFzdF9oaWRkZW5fc3RhdGUlMEFsaXN0KGxhc3RfaGlkZGVuX3N0YXRlcy5zaGFwZSk=",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoImageProcessor, TFRegNetModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;huggingface/cats-image&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>image = dataset[<span class="hljs-string">&quot;test&quot;</span>][<span class="hljs-string">&quot;image&quot;</span>][<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>image_processor = AutoImageProcessor.from_pretrained(<span class="hljs-string">&quot;facebook/regnet-y-040&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFRegNetModel.from_pretrained(<span class="hljs-string">&quot;facebook/regnet-y-040&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = image_processor(image, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(last_hidden_states.shape)
[<span class="hljs-number">1</span>, <span class="hljs-number">1088</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>]`,wrap:!1}}),{c(){e=g("p"),e.textContent=c,t=l(),b(n.$$.fragment)},l(s){e=f(s,"P",{"data-svelte-h":!0}),x(e)!=="svelte-11lpom8"&&(e.textContent=c),t=i(s),y(n.$$.fragment,s)},m(s,j){m(s,e,j),m(s,t,j),$(n,s,j),p=!0},p:he,i(s){p||(w(n.$$.fragment,s),p=!0)},o(s){M(n.$$.fragment,s),p=!1},d(s){s&&(r(e),r(t)),T(n,s)}}}function Oe(F){let e,c=`Although the recipe for forward pass needs to be defined within this function, one should call the <code>Module</code>
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`;return{c(){e=g("p"),e.innerHTML=c},l(t){e=f(t,"P",{"data-svelte-h":!0}),x(e)!=="svelte-fincs2"&&(e.innerHTML=c)},m(t,n){m(t,e,n)},p:he,d(t){t&&r(e)}}}function Ke(F){let e,c="Example:",t,n,p;return n=new Re({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9JbWFnZVByb2Nlc3NvciUyQyUyMFRGUmVnTmV0Rm9ySW1hZ2VDbGFzc2lmaWNhdGlvbiUwQWltcG9ydCUyMHRlbnNvcmZsb3clMjBhcyUyMHRmJTBBZnJvbSUyMGRhdGFzZXRzJTIwaW1wb3J0JTIwbG9hZF9kYXRhc2V0JTBBJTBBZGF0YXNldCUyMCUzRCUyMGxvYWRfZGF0YXNldCglMjJodWdnaW5nZmFjZSUyRmNhdHMtaW1hZ2UlMjIpJTBBaW1hZ2UlMjAlM0QlMjBkYXRhc2V0JTVCJTIydGVzdCUyMiU1RCU1QiUyMmltYWdlJTIyJTVEJTVCMCU1RCUwQSUwQWltYWdlX3Byb2Nlc3NvciUyMCUzRCUyMEF1dG9JbWFnZVByb2Nlc3Nvci5mcm9tX3ByZXRyYWluZWQoJTIyZmFjZWJvb2slMkZyZWduZXQteS0wNDAlMjIpJTBBbW9kZWwlMjAlM0QlMjBURlJlZ05ldEZvckltYWdlQ2xhc3NpZmljYXRpb24uZnJvbV9wcmV0cmFpbmVkKCUyMmZhY2Vib29rJTJGcmVnbmV0LXktMDQwJTIyKSUwQSUwQWlucHV0cyUyMCUzRCUyMGltYWdlX3Byb2Nlc3NvcihpbWFnZSUyQyUyMHJldHVybl90ZW5zb3JzJTNEJTIydGYlMjIpJTBBbG9naXRzJTIwJTNEJTIwbW9kZWwoKippbnB1dHMpLmxvZ2l0cyUwQSUwQSUyMyUyMG1vZGVsJTIwcHJlZGljdHMlMjBvbmUlMjBvZiUyMHRoZSUyMDEwMDAlMjBJbWFnZU5ldCUyMGNsYXNzZXMlMEFwcmVkaWN0ZWRfbGFiZWwlMjAlM0QlMjBpbnQodGYubWF0aC5hcmdtYXgobG9naXRzJTJDJTIwYXhpcyUzRC0xKSklMEFwcmludChtb2RlbC5jb25maWcuaWQybGFiZWwlNUJwcmVkaWN0ZWRfbGFiZWwlNUQp",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoImageProcessor, TFRegNetForImageClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;huggingface/cats-image&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>image = dataset[<span class="hljs-string">&quot;test&quot;</span>][<span class="hljs-string">&quot;image&quot;</span>][<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>image_processor = AutoImageProcessor.from_pretrained(<span class="hljs-string">&quot;facebook/regnet-y-040&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFRegNetForImageClassification.from_pretrained(<span class="hljs-string">&quot;facebook/regnet-y-040&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = image_processor(image, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># model predicts one of the 1000 ImageNet classes</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_label = <span class="hljs-built_in">int</span>(tf.math.argmax(logits, axis=-<span class="hljs-number">1</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(model.config.id2label[predicted_label])
tabby, tabby cat`,wrap:!1}}),{c(){e=g("p"),e.textContent=c,t=l(),b(n.$$.fragment)},l(s){e=f(s,"P",{"data-svelte-h":!0}),x(e)!=="svelte-11lpom8"&&(e.textContent=c),t=i(s),y(n.$$.fragment,s)},m(s,j){m(s,e,j),m(s,t,j),$(n,s,j),p=!0},p:he,i(s){p||(w(n.$$.fragment,s),p=!0)},o(s){M(n.$$.fragment,s),p=!1},d(s){s&&(r(e),r(t)),T(n,s)}}}function et(F){let e,c,t,n,p,s,j=`The bare RegNet model outputting raw features without any specific head on top.
This model is a Tensorflow
<a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Layer" rel="nofollow">keras.layers.Layer</a> sub-class. Use it as a
regular Tensorflow Module and refer to the Tensorflow documentation for all matter related to general usage and
behavior.`,ne,C,X,ae,z,be='The <a href="/docs/transformers/main/en/model_doc/regnet#transformers.TFRegNetModel">TFRegNetModel</a> forward method, overrides the <code>__call__</code> special method.',oe,Z,pe,P,L,Y,ee,u,H,re,B,ye=`RegNet Model with an image classification head on top (a linear layer on top of the pooled features), e.g. for
ImageNet.`,le,k,ce=`This model is a Tensorflow
<a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Layer" rel="nofollow">keras.layers.Layer</a> sub-class. Use it as a
regular Tensorflow Module and refer to the Tensorflow documentation for all matter related to general usage and
behavior.`,E,U,V,D,R,q='The <a href="/docs/transformers/main/en/model_doc/regnet#transformers.TFRegNetForImageClassification">TFRegNetForImageClassification</a> forward method, overrides the <code>__call__</code> special method.',me,G,te,Q,S;return e=new Te({props:{title:"TFRegNetModel",local:"transformers.TFRegNetModel",headingTag:"h2"}}),n=new fe({props:{name:"class transformers.TFRegNetModel",anchor:"transformers.TFRegNetModel",parameters:[{name:"config",val:": RegNetConfig"},{name:"*inputs",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFRegNetModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/regnet#transformers.RegNetConfig">RegNetConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/regnet/modeling_tf_regnet.py#L489"}}),X=new fe({props:{name:"call",anchor:"transformers.TFRegNetModel.call",parameters:[{name:"pixel_values",val:": Tensor"},{name:"output_hidden_states",val:": Optional = None"},{name:"return_dict",val:": Optional = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFRegNetModel.call.pixel_values",description:`<strong>pixel_values</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Pixel values can be obtained using <a href="/docs/transformers/main/en/model_doc/auto#transformers.AutoImageProcessor">AutoImageProcessor</a>. See
<code>ConveNextImageProcessor.__call__</code> for details.`,name:"pixel_values"},{anchor:"transformers.TFRegNetModel.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.TFRegNetModel.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/regnet/modeling_tf_regnet.py#L498",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>A <code>transformers.modeling_tf_outputs.TFBaseModelOutputWithPoolingAndNoAttention</code> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/regnet#transformers.RegNetConfig"
>RegNetConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) — Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>pooler_output</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, hidden_size)</code>) — Last layer hidden-state after a pooling operation on the spatial dimensions.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) — Tuple of <code>tf.Tensor</code> (one for the output of the embeddings, if the model has an embedding layer, + one for
the output of each layer) of shape <code>(batch_size, num_channels, height, width)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
</ul>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>transformers.modeling_tf_outputs.TFBaseModelOutputWithPoolingAndNoAttention</code> or <code>tuple(tf.Tensor)</code></p>
`}}),Z=new Je({props:{$$slots:{default:[Ae]},$$scope:{ctx:F}}}),P=new Fe({props:{anchor:"transformers.TFRegNetModel.call.example",$$slots:{default:[De]},$$scope:{ctx:F}}}),Y=new Te({props:{title:"TFRegNetForImageClassification",local:"transformers.TFRegNetForImageClassification",headingTag:"h2"}}),H=new fe({props:{name:"class transformers.TFRegNetForImageClassification",anchor:"transformers.TFRegNetForImageClassification",parameters:[{name:"config",val:": RegNetConfig"},{name:"*inputs",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFRegNetForImageClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/regnet#transformers.RegNetConfig">RegNetConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.TFPreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/regnet/modeling_tf_regnet.py#L543"}}),V=new fe({props:{name:"call",anchor:"transformers.TFRegNetForImageClassification.call",parameters:[{name:"pixel_values",val:": Optional = None"},{name:"labels",val:": Optional = None"},{name:"output_hidden_states",val:": Optional = None"},{name:"return_dict",val:": Optional = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFRegNetForImageClassification.call.pixel_values",description:`<strong>pixel_values</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Pixel values can be obtained using <a href="/docs/transformers/main/en/model_doc/auto#transformers.AutoImageProcessor">AutoImageProcessor</a>. See
<code>ConveNextImageProcessor.__call__</code> for details.`,name:"pixel_values"},{anchor:"transformers.TFRegNetForImageClassification.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.TFRegNetForImageClassification.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.TFRegNetForImageClassification.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the image classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/regnet/modeling_tf_regnet.py#L561",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFSequenceClassifierOutput"
>transformers.modeling_tf_outputs.TFSequenceClassifierOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/main/en/model_doc/regnet#transformers.RegNetConfig"
>RegNetConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, )</code>, <em>optional</em>, returned when <code>labels</code> is provided) — Classification (or regression if config.num_labels==1) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, config.num_labels)</code>) — Classification (or regression if config.num_labels==1) scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) — Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) — Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_tf_outputs.TFSequenceClassifierOutput"
>transformers.modeling_tf_outputs.TFSequenceClassifierOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),G=new Je({props:{$$slots:{default:[Oe]},$$scope:{ctx:F}}}),Q=new Fe({props:{anchor:"transformers.TFRegNetForImageClassification.call.example",$$slots:{default:[Ke]},$$scope:{ctx:F}}}),{c(){b(e.$$.fragment),c=l(),t=g("div"),b(n.$$.fragment),p=l(),s=g("p"),s.innerHTML=j,ne=l(),C=g("div"),b(X.$$.fragment),ae=l(),z=g("p"),z.innerHTML=be,oe=l(),b(Z.$$.fragment),pe=l(),b(P.$$.fragment),L=l(),b(Y.$$.fragment),ee=l(),u=g("div"),b(H.$$.fragment),re=l(),B=g("p"),B.textContent=ye,le=l(),k=g("p"),k.innerHTML=ce,E=l(),U=g("div"),b(V.$$.fragment),D=l(),R=g("p"),R.innerHTML=q,me=l(),b(G.$$.fragment),te=l(),b(Q.$$.fragment),this.h()},l(o){y(e.$$.fragment,o),c=i(o),t=f(o,"DIV",{class:!0});var h=ie(t);y(n.$$.fragment,h),p=i(h),s=f(h,"P",{"data-svelte-h":!0}),x(s)!=="svelte-xzl4r8"&&(s.innerHTML=j),ne=i(h),C=f(h,"DIV",{class:!0});var N=ie(C);y(X.$$.fragment,N),ae=i(N),z=f(N,"P",{"data-svelte-h":!0}),x(z)!=="svelte-1imc2ag"&&(z.innerHTML=be),oe=i(N),y(Z.$$.fragment,N),pe=i(N),y(P.$$.fragment,N),N.forEach(r),h.forEach(r),L=i(o),y(Y.$$.fragment,o),ee=i(o),u=f(o,"DIV",{class:!0});var J=ie(u);y(H.$$.fragment,J),re=i(J),B=f(J,"P",{"data-svelte-h":!0}),x(B)!=="svelte-ipsb0r"&&(B.textContent=ye),le=i(J),k=f(J,"P",{"data-svelte-h":!0}),x(k)!=="svelte-1g64psv"&&(k.innerHTML=ce),E=i(J),U=f(J,"DIV",{class:!0});var W=ie(U);y(V.$$.fragment,W),D=i(W),R=f(W,"P",{"data-svelte-h":!0}),x(R)!=="svelte-dozala"&&(R.innerHTML=q),me=i(W),y(G.$$.fragment,W),te=i(W),y(Q.$$.fragment,W),W.forEach(r),J.forEach(r),this.h()},h(){de(C,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),de(t,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),de(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),de(u,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(o,h){$(e,o,h),m(o,c,h),m(o,t,h),$(n,t,null),d(t,p),d(t,s),d(t,ne),d(t,C),$(X,C,null),d(C,ae),d(C,z),d(C,oe),$(Z,C,null),d(C,pe),$(P,C,null),m(o,L,h),$(Y,o,h),m(o,ee,h),m(o,u,h),$(H,u,null),d(u,re),d(u,B),d(u,le),d(u,k),d(u,E),d(u,U),$(V,U,null),d(U,D),d(U,R),d(U,me),$(G,U,null),d(U,te),$(Q,U,null),S=!0},p(o,h){const N={};h&2&&(N.$$scope={dirty:h,ctx:o}),Z.$set(N);const J={};h&2&&(J.$$scope={dirty:h,ctx:o}),P.$set(J);const W={};h&2&&(W.$$scope={dirty:h,ctx:o}),G.$set(W);const K={};h&2&&(K.$$scope={dirty:h,ctx:o}),Q.$set(K)},i(o){S||(w(e.$$.fragment,o),w(n.$$.fragment,o),w(X.$$.fragment,o),w(Z.$$.fragment,o),w(P.$$.fragment,o),w(Y.$$.fragment,o),w(H.$$.fragment,o),w(V.$$.fragment,o),w(G.$$.fragment,o),w(Q.$$.fragment,o),S=!0)},o(o){M(e.$$.fragment,o),M(n.$$.fragment,o),M(X.$$.fragment,o),M(Z.$$.fragment,o),M(P.$$.fragment,o),M(Y.$$.fragment,o),M(H.$$.fragment,o),M(V.$$.fragment,o),M(G.$$.fragment,o),M(Q.$$.fragment,o),S=!1},d(o){o&&(r(c),r(t),r(L),r(ee),r(u)),T(e,o),T(n),T(X),T(Z),T(P),T(Y,o),T(H),T(V),T(G),T(Q)}}}function tt(F){let e,c;return e=new We({props:{$$slots:{default:[et]},$$scope:{ctx:F}}}),{c(){b(e.$$.fragment)},l(t){y(e.$$.fragment,t)},m(t,n){$(e,t,n),c=!0},p(t,n){const p={};n&2&&(p.$$scope={dirty:n,ctx:t}),e.$set(p)},i(t){c||(w(e.$$.fragment,t),c=!0)},o(t){M(e.$$.fragment,t),c=!1},d(t){T(e,t)}}}function st(F){let e,c=`Although the recipe for forward pass needs to be defined within this function, one should call the <code>Module</code>
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`;return{c(){e=g("p"),e.innerHTML=c},l(t){e=f(t,"P",{"data-svelte-h":!0}),x(e)!=="svelte-fincs2"&&(e.innerHTML=c)},m(t,n){m(t,e,n)},p:he,d(t){t&&r(e)}}}function nt(F){let e,c="Examples:",t,n,p;return n=new Re({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9JbWFnZVByb2Nlc3NvciUyQyUyMEZsYXhSZWdOZXRNb2RlbCUwQWZyb20lMjBQSUwlMjBpbXBvcnQlMjBJbWFnZSUwQWltcG9ydCUyMHJlcXVlc3RzJTBBJTBBdXJsJTIwJTNEJTIwJTIyaHR0cCUzQSUyRiUyRmltYWdlcy5jb2NvZGF0YXNldC5vcmclMkZ2YWwyMDE3JTJGMDAwMDAwMDM5NzY5LmpwZyUyMiUwQWltYWdlJTIwJTNEJTIwSW1hZ2Uub3BlbihyZXF1ZXN0cy5nZXQodXJsJTJDJTIwc3RyZWFtJTNEVHJ1ZSkucmF3KSUwQSUwQWltYWdlX3Byb2Nlc3NvciUyMCUzRCUyMEF1dG9JbWFnZVByb2Nlc3Nvci5mcm9tX3ByZXRyYWluZWQoJTIyZmFjZWJvb2slMkZyZWduZXQteS0wNDAlMjIpJTBBbW9kZWwlMjAlM0QlMjBGbGF4UmVnTmV0TW9kZWwuZnJvbV9wcmV0cmFpbmVkKCUyMmZhY2Vib29rJTJGcmVnbmV0LXktMDQwJTIyKSUwQSUwQWlucHV0cyUyMCUzRCUyMGltYWdlX3Byb2Nlc3NvcihpbWFnZXMlM0RpbWFnZSUyQyUyMHJldHVybl90ZW5zb3JzJTNEJTIybnAlMjIpJTBBb3V0cHV0cyUyMCUzRCUyMG1vZGVsKCoqaW5wdXRzKSUwQWxhc3RfaGlkZGVuX3N0YXRlcyUyMCUzRCUyMG91dHB1dHMubGFzdF9oaWRkZW5fc3RhdGU=",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoImageProcessor, FlaxRegNetModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests

<span class="hljs-meta">&gt;&gt;&gt; </span>url = <span class="hljs-string">&quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>image = Image.<span class="hljs-built_in">open</span>(requests.get(url, stream=<span class="hljs-literal">True</span>).raw)

<span class="hljs-meta">&gt;&gt;&gt; </span>image_processor = AutoImageProcessor.from_pretrained(<span class="hljs-string">&quot;facebook/regnet-y-040&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FlaxRegNetModel.from_pretrained(<span class="hljs-string">&quot;facebook/regnet-y-040&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = image_processor(images=image, return_tensors=<span class="hljs-string">&quot;np&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`,wrap:!1}}),{c(){e=g("p"),e.textContent=c,t=l(),b(n.$$.fragment)},l(s){e=f(s,"P",{"data-svelte-h":!0}),x(e)!=="svelte-kvfsh7"&&(e.textContent=c),t=i(s),y(n.$$.fragment,s)},m(s,j){m(s,e,j),m(s,t,j),$(n,s,j),p=!0},p:he,i(s){p||(w(n.$$.fragment,s),p=!0)},o(s){M(n.$$.fragment,s),p=!1},d(s){s&&(r(e),r(t)),T(n,s)}}}function at(F){let e,c=`Although the recipe for forward pass needs to be defined within this function, one should call the <code>Module</code>
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`;return{c(){e=g("p"),e.innerHTML=c},l(t){e=f(t,"P",{"data-svelte-h":!0}),x(e)!=="svelte-fincs2"&&(e.innerHTML=c)},m(t,n){m(t,e,n)},p:he,d(t){t&&r(e)}}}function ot(F){let e,c="Example:",t,n,p;return n=new Re({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9JbWFnZVByb2Nlc3NvciUyQyUyMEZsYXhSZWdOZXRGb3JJbWFnZUNsYXNzaWZpY2F0aW9uJTBBZnJvbSUyMFBJTCUyMGltcG9ydCUyMEltYWdlJTBBaW1wb3J0JTIwamF4JTBBaW1wb3J0JTIwcmVxdWVzdHMlMEElMEF1cmwlMjAlM0QlMjAlMjJodHRwJTNBJTJGJTJGaW1hZ2VzLmNvY29kYXRhc2V0Lm9yZyUyRnZhbDIwMTclMkYwMDAwMDAwMzk3NjkuanBnJTIyJTBBaW1hZ2UlMjAlM0QlMjBJbWFnZS5vcGVuKHJlcXVlc3RzLmdldCh1cmwlMkMlMjBzdHJlYW0lM0RUcnVlKS5yYXcpJTBBJTBBaW1hZ2VfcHJvY2Vzc29yJTIwJTNEJTIwQXV0b0ltYWdlUHJvY2Vzc29yLmZyb21fcHJldHJhaW5lZCglMjJmYWNlYm9vayUyRnJlZ25ldC15LTA0MCUyMiklMEFtb2RlbCUyMCUzRCUyMEZsYXhSZWdOZXRGb3JJbWFnZUNsYXNzaWZpY2F0aW9uLmZyb21fcHJldHJhaW5lZCglMjJmYWNlYm9vayUyRnJlZ25ldC15LTA0MCUyMiklMEElMEFpbnB1dHMlMjAlM0QlMjBpbWFnZV9wcm9jZXNzb3IoaW1hZ2VzJTNEaW1hZ2UlMkMlMjByZXR1cm5fdGVuc29ycyUzRCUyMm5wJTIyKSUwQW91dHB1dHMlMjAlM0QlMjBtb2RlbCgqKmlucHV0cyklMEFsb2dpdHMlMjAlM0QlMjBvdXRwdXRzLmxvZ2l0cyUwQSUwQSUyMyUyMG1vZGVsJTIwcHJlZGljdHMlMjBvbmUlMjBvZiUyMHRoZSUyMDEwMDAlMjBJbWFnZU5ldCUyMGNsYXNzZXMlMEFwcmVkaWN0ZWRfY2xhc3NfaWR4JTIwJTNEJTIwamF4Lm51bXB5LmFyZ21heChsb2dpdHMlMkMlMjBheGlzJTNELTEpJTBBcHJpbnQoJTIyUHJlZGljdGVkJTIwY2xhc3MlM0ElMjIlMkMlMjBtb2RlbC5jb25maWcuaWQybGFiZWwlNUJwcmVkaWN0ZWRfY2xhc3NfaWR4Lml0ZW0oKSU1RCk=",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoImageProcessor, FlaxRegNetForImageClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> jax
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests

<span class="hljs-meta">&gt;&gt;&gt; </span>url = <span class="hljs-string">&quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>image = Image.<span class="hljs-built_in">open</span>(requests.get(url, stream=<span class="hljs-literal">True</span>).raw)

<span class="hljs-meta">&gt;&gt;&gt; </span>image_processor = AutoImageProcessor.from_pretrained(<span class="hljs-string">&quot;facebook/regnet-y-040&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FlaxRegNetForImageClassification.from_pretrained(<span class="hljs-string">&quot;facebook/regnet-y-040&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = image_processor(images=image, return_tensors=<span class="hljs-string">&quot;np&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># model predicts one of the 1000 ImageNet classes</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_class_idx = jax.numpy.argmax(logits, axis=-<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Predicted class:&quot;</span>, model.config.id2label[predicted_class_idx.item()])`,wrap:!1}}),{c(){e=g("p"),e.textContent=c,t=l(),b(n.$$.fragment)},l(s){e=f(s,"P",{"data-svelte-h":!0}),x(e)!=="svelte-11lpom8"&&(e.textContent=c),t=i(s),y(n.$$.fragment,s)},m(s,j){m(s,e,j),m(s,t,j),$(n,s,j),p=!0},p:he,i(s){p||(w(n.$$.fragment,s),p=!0)},o(s){M(n.$$.fragment,s),p=!1},d(s){s&&(r(e),r(t)),T(n,s)}}}function rt(F){let e,c,t,n,p,s,j="The bare RegNet model outputting raw features without any specific head on top.",ne,C,X=`This model inherits from <a href="/docs/transformers/main/en/main_classes/model#transformers.FlaxPreTrainedModel">FlaxPreTrainedModel</a>. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading, saving and converting weights from PyTorch models)`,ae,z,be=`This model is also a
<a href="https://flax.readthedocs.io/en/latest/api_reference/flax.linen/module.html" rel="nofollow">flax.linen.Module</a> subclass. Use it as
a regular Flax linen Module and refer to the Flax documentation for all matter related to general usage and
behavior.`,oe,Z,pe="Finally, this model supports inherent JAX features such as:",P,L,Y='<li><a href="https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit" rel="nofollow">Just-In-Time (JIT) compilation</a></li> <li><a href="https://jax.readthedocs.io/en/latest/jax.html#automatic-differentiation" rel="nofollow">Automatic Differentiation</a></li> <li><a href="https://jax.readthedocs.io/en/latest/jax.html#vectorization-vmap" rel="nofollow">Vectorization</a></li> <li><a href="https://jax.readthedocs.io/en/latest/jax.html#parallelization-pmap" rel="nofollow">Parallelization</a></li>',ee,u,H,re,B,ye="The <code>FlaxRegNetPreTrainedModel</code> forward method, overrides the <code>__call__</code> special method.",le,k,ce,E,U,V,D,R,q,me,G,te=`RegNet Model with an image classification head on top (a linear layer on top of the pooled features), e.g. for
ImageNet.`,Q,S,o=`This model inherits from <a href="/docs/transformers/main/en/main_classes/model#transformers.FlaxPreTrainedModel">FlaxPreTrainedModel</a>. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading, saving and converting weights from PyTorch models)`,h,N,J=`This model is also a
<a href="https://flax.readthedocs.io/en/latest/api_reference/flax.linen/module.html" rel="nofollow">flax.linen.Module</a> subclass. Use it as
a regular Flax linen Module and refer to the Flax documentation for all matter related to general usage and
behavior.`,W,K,Ue="Finally, this model supports inherent JAX features such as:",je,ge,Ze='<li><a href="https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit" rel="nofollow">Just-In-Time (JIT) compilation</a></li> <li><a href="https://jax.readthedocs.io/en/latest/jax.html#automatic-differentiation" rel="nofollow">Automatic Differentiation</a></li> <li><a href="https://jax.readthedocs.io/en/latest/jax.html#vectorization-vmap" rel="nofollow">Vectorization</a></li> <li><a href="https://jax.readthedocs.io/en/latest/jax.html#parallelization-pmap" rel="nofollow">Parallelization</a></li>',Ne,A,ue,_e,$e,ve="The <code>FlaxRegNetPreTrainedModel</code> forward method, overrides the <code>__call__</code> special method.",xe,a,_,O,Ce;return e=new Te({props:{title:"FlaxRegNetModel",local:"transformers.FlaxRegNetModel",headingTag:"h2"}}),n=new fe({props:{name:"class transformers.FlaxRegNetModel",anchor:"transformers.FlaxRegNetModel",parameters:[{name:"config",val:": RegNetConfig"},{name:"input_shape",val:" = (1, 224, 224, 3)"},{name:"seed",val:": int = 0"},{name:"dtype",val:": dtype = <class 'jax.numpy.float32'>"},{name:"_do_init",val:": bool = True"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.FlaxRegNetModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/regnet#transformers.RegNetConfig">RegNetConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.FlaxPreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"transformers.FlaxRegNetModel.dtype",description:`<strong>dtype</strong> (<code>jax.numpy.dtype</code>, <em>optional</em>, defaults to <code>jax.numpy.float32</code>) &#x2014;
The data type of the computation. Can be one of <code>jax.numpy.float32</code>, <code>jax.numpy.float16</code> (on GPUs) and
<code>jax.numpy.bfloat16</code> (on TPUs).</p>
<p>This can be used to enable mixed-precision training or half-precision inference on GPUs or TPUs. If
specified all the computation will be performed with the given <code>dtype</code>.</p>
<p><strong>Note that this only specifies the dtype of the computation and does not influence the dtype of model
parameters.</strong></p>
<p>If you wish to change the dtype of the model parameters, see <a href="/docs/transformers/main/en/main_classes/model#transformers.FlaxPreTrainedModel.to_fp16">to_fp16()</a> and
<a href="/docs/transformers/main/en/main_classes/model#transformers.FlaxPreTrainedModel.to_bf16">to_bf16()</a>.`,name:"dtype"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/regnet/modeling_flax_regnet.py#L686"}}),H=new fe({props:{name:"__call__",anchor:"transformers.FlaxRegNetModel.__call__",parameters:[{name:"pixel_values",val:""},{name:"params",val:": dict = None"},{name:"train",val:": bool = False"},{name:"output_hidden_states",val:": Optional = None"},{name:"return_dict",val:": Optional = None"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/regnet/modeling_flax_regnet.py#L597",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>A <a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_flax_outputs.FlaxBaseModelOutputWithPooling"
>transformers.modeling_flax_outputs.FlaxBaseModelOutputWithPooling</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<code>&lt;class 'transformers.models.regnet.configuration_regnet.RegNetConfig'&gt;</code>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) — Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>pooler_output</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, hidden_size)</code>) — Last layer hidden-state of the first token of the sequence (classification token) further processed by a
Linear layer and a Tanh activation function. The Linear layer weights are trained from the next sentence
prediction (classification) objective during pretraining.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(jnp.ndarray)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) — Tuple of <code>jnp.ndarray</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(jnp.ndarray)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) — Tuple of <code>jnp.ndarray</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><a
  href="/docs/transformers/main/en/main_classes/output#transformers.modeling_flax_outputs.FlaxBaseModelOutputWithPooling"
>transformers.modeling_flax_outputs.FlaxBaseModelOutputWithPooling</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),k=new Je({props:{$$slots:{default:[st]},$$scope:{ctx:F}}}),E=new Fe({props:{anchor:"transformers.FlaxRegNetModel.__call__.example",$$slots:{default:[nt]},$$scope:{ctx:F}}}),V=new Te({props:{title:"FlaxRegNetForImageClassification",local:"transformers.FlaxRegNetForImageClassification",headingTag:"h2"}}),q=new fe({props:{name:"class transformers.FlaxRegNetForImageClassification",anchor:"transformers.FlaxRegNetForImageClassification",parameters:[{name:"config",val:": RegNetConfig"},{name:"input_shape",val:" = (1, 224, 224, 3)"},{name:"seed",val:": int = 0"},{name:"dtype",val:": dtype = <class 'jax.numpy.float32'>"},{name:"_do_init",val:": bool = True"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.FlaxRegNetForImageClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/regnet#transformers.RegNetConfig">RegNetConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/main/en/main_classes/model#transformers.FlaxPreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"transformers.FlaxRegNetForImageClassification.dtype",description:`<strong>dtype</strong> (<code>jax.numpy.dtype</code>, <em>optional</em>, defaults to <code>jax.numpy.float32</code>) &#x2014;
The data type of the computation. Can be one of <code>jax.numpy.float32</code>, <code>jax.numpy.float16</code> (on GPUs) and
<code>jax.numpy.bfloat16</code> (on TPUs).</p>
<p>This can be used to enable mixed-precision training or half-precision inference on GPUs or TPUs. If
specified all the computation will be performed with the given <code>dtype</code>.</p>
<p><strong>Note that this only specifies the dtype of the computation and does not influence the dtype of model
parameters.</strong></p>
<p>If you wish to change the dtype of the model parameters, see <a href="/docs/transformers/main/en/main_classes/model#transformers.FlaxPreTrainedModel.to_fp16">to_fp16()</a> and
<a href="/docs/transformers/main/en/main_classes/model#transformers.FlaxPreTrainedModel.to_bf16">to_bf16()</a>.`,name:"dtype"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/regnet/modeling_flax_regnet.py#L776"}}),ue=new fe({props:{name:"__call__",anchor:"transformers.FlaxRegNetForImageClassification.__call__",parameters:[{name:"pixel_values",val:""},{name:"params",val:": dict = None"},{name:"train",val:": bool = False"},{name:"output_hidden_states",val:": Optional = None"},{name:"return_dict",val:": Optional = None"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/regnet/modeling_flax_regnet.py#L597",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>A <code>transformers.modeling_flax_outputs.FlaxImageClassifierOutputWithNoAttention</code> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<code>&lt;class 'transformers.models.regnet.configuration_regnet.RegNetConfig'&gt;</code>) and inputs.</p>
<ul>
<li><strong>logits</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, config.num_labels)</code>) — Classification (or regression if config.num_labels==1) scores (before SoftMax).</li>
<li><strong>hidden_states</strong> (<code>tuple(jnp.ndarray)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when</li>
<li><strong><code>config.output_hidden_states=True</code>):</strong>
Tuple of <code>jnp.ndarray</code> (one for the output of the embeddings, if the model has an embedding layer, + one
for the output of each stage) of shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also
called feature maps) of the model at the output of each stage.</li>
</ul>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>transformers.modeling_flax_outputs.FlaxImageClassifierOutputWithNoAttention</code> or <code>tuple(torch.FloatTensor)</code></p>
`}}),a=new Je({props:{$$slots:{default:[at]},$$scope:{ctx:F}}}),O=new Fe({props:{anchor:"transformers.FlaxRegNetForImageClassification.__call__.example",$$slots:{default:[ot]},$$scope:{ctx:F}}}),{c(){b(e.$$.fragment),c=l(),t=g("div"),b(n.$$.fragment),p=l(),s=g("p"),s.textContent=j,ne=l(),C=g("p"),C.innerHTML=X,ae=l(),z=g("p"),z.innerHTML=be,oe=l(),Z=g("p"),Z.textContent=pe,P=l(),L=g("ul"),L.innerHTML=Y,ee=l(),u=g("div"),b(H.$$.fragment),re=l(),B=g("p"),B.innerHTML=ye,le=l(),b(k.$$.fragment),ce=l(),b(E.$$.fragment),U=l(),b(V.$$.fragment),D=l(),R=g("div"),b(q.$$.fragment),me=l(),G=g("p"),G.textContent=te,Q=l(),S=g("p"),S.innerHTML=o,h=l(),N=g("p"),N.innerHTML=J,W=l(),K=g("p"),K.textContent=Ue,je=l(),ge=g("ul"),ge.innerHTML=Ze,Ne=l(),A=g("div"),b(ue.$$.fragment),_e=l(),$e=g("p"),$e.innerHTML=ve,xe=l(),b(a.$$.fragment),_=l(),b(O.$$.fragment),this.h()},l(v){y(e.$$.fragment,v),c=i(v),t=f(v,"DIV",{class:!0});var I=ie(t);y(n.$$.fragment,I),p=i(I),s=f(I,"P",{"data-svelte-h":!0}),x(s)!=="svelte-1lrc7eh"&&(s.textContent=j),ne=i(I),C=f(I,"P",{"data-svelte-h":!0}),x(C)!=="svelte-3daxed"&&(C.innerHTML=X),ae=i(I),z=f(I,"P",{"data-svelte-h":!0}),x(z)!=="svelte-10nfsf3"&&(z.innerHTML=be),oe=i(I),Z=f(I,"P",{"data-svelte-h":!0}),x(Z)!=="svelte-1pplc4a"&&(Z.textContent=pe),P=i(I),L=f(I,"UL",{"data-svelte-h":!0}),x(L)!=="svelte-1w7z84m"&&(L.innerHTML=Y),ee=i(I),u=f(I,"DIV",{class:!0});var we=ie(u);y(H.$$.fragment,we),re=i(we),B=f(we,"P",{"data-svelte-h":!0}),x(B)!=="svelte-1xwpegk"&&(B.innerHTML=ye),le=i(we),y(k.$$.fragment,we),ce=i(we),y(E.$$.fragment,we),we.forEach(r),I.forEach(r),U=i(v),y(V.$$.fragment,v),D=i(v),R=f(v,"DIV",{class:!0});var se=ie(R);y(q.$$.fragment,se),me=i(se),G=f(se,"P",{"data-svelte-h":!0}),x(G)!=="svelte-ipsb0r"&&(G.textContent=te),Q=i(se),S=f(se,"P",{"data-svelte-h":!0}),x(S)!=="svelte-3daxed"&&(S.innerHTML=o),h=i(se),N=f(se,"P",{"data-svelte-h":!0}),x(N)!=="svelte-10nfsf3"&&(N.innerHTML=J),W=i(se),K=f(se,"P",{"data-svelte-h":!0}),x(K)!=="svelte-1pplc4a"&&(K.textContent=Ue),je=i(se),ge=f(se,"UL",{"data-svelte-h":!0}),x(ge)!=="svelte-1w7z84m"&&(ge.innerHTML=Ze),Ne=i(se),A=f(se,"DIV",{class:!0});var Me=ie(A);y(ue.$$.fragment,Me),_e=i(Me),$e=f(Me,"P",{"data-svelte-h":!0}),x($e)!=="svelte-1xwpegk"&&($e.innerHTML=ve),xe=i(Me),y(a.$$.fragment,Me),_=i(Me),y(O.$$.fragment,Me),Me.forEach(r),se.forEach(r),this.h()},h(){de(u,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),de(t,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),de(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),de(R,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(v,I){$(e,v,I),m(v,c,I),m(v,t,I),$(n,t,null),d(t,p),d(t,s),d(t,ne),d(t,C),d(t,ae),d(t,z),d(t,oe),d(t,Z),d(t,P),d(t,L),d(t,ee),d(t,u),$(H,u,null),d(u,re),d(u,B),d(u,le),$(k,u,null),d(u,ce),$(E,u,null),m(v,U,I),$(V,v,I),m(v,D,I),m(v,R,I),$(q,R,null),d(R,me),d(R,G),d(R,Q),d(R,S),d(R,h),d(R,N),d(R,W),d(R,K),d(R,je),d(R,ge),d(R,Ne),d(R,A),$(ue,A,null),d(A,_e),d(A,$e),d(A,xe),$(a,A,null),d(A,_),$(O,A,null),Ce=!0},p(v,I){const we={};I&2&&(we.$$scope={dirty:I,ctx:v}),k.$set(we);const se={};I&2&&(se.$$scope={dirty:I,ctx:v}),E.$set(se);const Me={};I&2&&(Me.$$scope={dirty:I,ctx:v}),a.$set(Me);const Ie={};I&2&&(Ie.$$scope={dirty:I,ctx:v}),O.$set(Ie)},i(v){Ce||(w(e.$$.fragment,v),w(n.$$.fragment,v),w(H.$$.fragment,v),w(k.$$.fragment,v),w(E.$$.fragment,v),w(V.$$.fragment,v),w(q.$$.fragment,v),w(ue.$$.fragment,v),w(a.$$.fragment,v),w(O.$$.fragment,v),Ce=!0)},o(v){M(e.$$.fragment,v),M(n.$$.fragment,v),M(H.$$.fragment,v),M(k.$$.fragment,v),M(E.$$.fragment,v),M(V.$$.fragment,v),M(q.$$.fragment,v),M(ue.$$.fragment,v),M(a.$$.fragment,v),M(O.$$.fragment,v),Ce=!1},d(v){v&&(r(c),r(t),r(U),r(D),r(R)),T(e,v),T(n),T(H),T(k),T(E),T(V,v),T(q),T(ue),T(a),T(O)}}}function lt(F){let e,c;return e=new We({props:{$$slots:{default:[rt]},$$scope:{ctx:F}}}),{c(){b(e.$$.fragment)},l(t){y(e.$$.fragment,t)},m(t,n){$(e,t,n),c=!0},p(t,n){const p={};n&2&&(p.$$scope={dirty:n,ctx:t}),e.$set(p)},i(t){c||(w(e.$$.fragment,t),c=!0)},o(t){M(e.$$.fragment,t),c=!1},d(t){T(e,t)}}}function it(F){let e,c,t,n,p,s,j,ne,C,X='The RegNet model was proposed in <a href="https://arxiv.org/abs/2003.13678" rel="nofollow">Designing Network Design Spaces</a> by Ilija Radosavovic, Raj Prateek Kosaraju, Ross Girshick, Kaiming He, Piotr Dollár.',ae,z,be="The authors design search spaces to perform Neural Architecture Search (NAS). They first start from a high dimensional search space and iteratively reduce the search space by empirically applying constraints based on the best-performing models sampled by the current search space.",oe,Z,pe="The abstract from the paper is the following:",P,L,Y="<em>In this work, we present a new network design paradigm. Our goal is to help advance the understanding of network design and discover design principles that generalize across settings. Instead of focusing on designing individual network instances, we design network design spaces that parametrize populations of networks. The overall process is analogous to classic manual design of networks, but elevated to the design space level. Using our methodology we explore the structure aspect of network design and arrive at a low-dimensional design space consisting of simple, regular networks that we call RegNet. The core insight of the RegNet parametrization is surprisingly simple: widths and depths of good networks can be explained by a quantized linear function. We analyze the RegNet design space and arrive at interesting findings that do not match the current practice of network design. The RegNet design space provides simple and fast networks that work well across a wide range of flop regimes. Under comparable training settings and flops, the RegNet models outperform the popular EfficientNet models while being up to 5x faster on GPUs.</em>",ee,u,H=`This model was contributed by <a href="https://huggingface.co/Francesco" rel="nofollow">Francesco</a>. The TensorFlow version of the model
was contributed by <a href="https://huggingface.co/sayakpaul" rel="nofollow">sayakpaul</a> and <a href="https://huggingface.co/ariG23498" rel="nofollow">ariG23498</a>.
The original code can be found <a href="https://github.com/facebookresearch/pycls" rel="nofollow">here</a>.`,re,B,ye=`The huge 10B model from <a href="https://arxiv.org/abs/2103.01988" rel="nofollow">Self-supervised Pretraining of Visual Features in the Wild</a>,
trained on  one billion Instagram images, is available on the <a href="https://huggingface.co/facebook/regnet-y-10b-seer" rel="nofollow">hub</a>`,le,k,ce,E,U="A list of official Hugging Face and community (indicated by 🌎) resources to help you get started with RegNet.",V,D,R,q,me='<li><a href="/docs/transformers/main/en/model_doc/regnet#transformers.RegNetForImageClassification">RegNetForImageClassification</a> is supported by this <a href="https://github.com/huggingface/transformers/tree/main/examples/pytorch/image-classification" rel="nofollow">example script</a> and <a href="https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/image_classification.ipynb" rel="nofollow">notebook</a>.</li> <li>See also: <a href="../tasks/image_classification">Image classification task guide</a></li>',G,te,Q="If you’re interested in submitting a resource to be included here, please feel free to open a Pull Request and we’ll review it! The resource should ideally demonstrate something new instead of duplicating an existing resource.",S,o,h,N,J,W,K,Ue=`This is the configuration class to store the configuration of a <a href="/docs/transformers/main/en/model_doc/regnet#transformers.RegNetModel">RegNetModel</a>. It is used to instantiate a RegNet
model according to the specified arguments, defining the model architecture. Instantiating a configuration with the
defaults will yield a similar configuration to that of the RegNet
<a href="https://huggingface.co/facebook/regnet-y-040" rel="nofollow">facebook/regnet-y-040</a> architecture.`,je,ge,Ze=`Configuration objects inherit from <a href="/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig">PretrainedConfig</a> and can be used to control the model outputs. Read the
documentation from <a href="/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig">PretrainedConfig</a> for more information.`,Ne,A,ue,_e,$e,ve,xe;return p=new Te({props:{title:"RegNet",local:"regnet",headingTag:"h1"}}),j=new Te({props:{title:"Overview",local:"overview",headingTag:"h2"}}),k=new Te({props:{title:"Resources",local:"resources",headingTag:"h2"}}),D=new He({props:{pipeline:"image-classification"}}),o=new Te({props:{title:"RegNetConfig",local:"transformers.RegNetConfig",headingTag:"h2"}}),J=new fe({props:{name:"class transformers.RegNetConfig",anchor:"transformers.RegNetConfig",parameters:[{name:"num_channels",val:" = 3"},{name:"embedding_size",val:" = 32"},{name:"hidden_sizes",val:" = [128, 192, 512, 1088]"},{name:"depths",val:" = [2, 6, 12, 2]"},{name:"groups_width",val:" = 64"},{name:"layer_type",val:" = 'y'"},{name:"hidden_act",val:" = 'relu'"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.RegNetConfig.num_channels",description:`<strong>num_channels</strong> (<code>int</code>, <em>optional</em>, defaults to 3) &#x2014;
The number of input channels.`,name:"num_channels"},{anchor:"transformers.RegNetConfig.embedding_size",description:`<strong>embedding_size</strong> (<code>int</code>, <em>optional</em>, defaults to 64) &#x2014;
Dimensionality (hidden size) for the embedding layer.`,name:"embedding_size"},{anchor:"transformers.RegNetConfig.hidden_sizes",description:`<strong>hidden_sizes</strong> (<code>List[int]</code>, <em>optional</em>, defaults to <code>[256, 512, 1024, 2048]</code>) &#x2014;
Dimensionality (hidden size) at each stage.`,name:"hidden_sizes"},{anchor:"transformers.RegNetConfig.depths",description:`<strong>depths</strong> (<code>List[int]</code>, <em>optional</em>, defaults to <code>[3, 4, 6, 3]</code>) &#x2014;
Depth (number of layers) for each stage.`,name:"depths"},{anchor:"transformers.RegNetConfig.layer_type",description:`<strong>layer_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;y&quot;</code>) &#x2014;
The layer to use, it can be either <code>&quot;x&quot; or </code>&#x201C;y&#x201D;<code>. An </code>x<code>layer is a ResNet&apos;s BottleNeck layer with</code>reduction<code>fixed to</code>1<code>. While a </code>y<code>layer is a</code>x\` but with squeeze and excitation. Please refer to the
paper for a detailed explanation of how these layers were constructed.`,name:"layer_type"},{anchor:"transformers.RegNetConfig.hidden_act",description:`<strong>hidden_act</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;relu&quot;</code>) &#x2014;
The non-linear activation function in each block. If string, <code>&quot;gelu&quot;</code>, <code>&quot;relu&quot;</code>, <code>&quot;selu&quot;</code> and <code>&quot;gelu_new&quot;</code>
are supported.`,name:"hidden_act"},{anchor:"transformers.RegNetConfig.downsample_in_first_stage",description:`<strong>downsample_in_first_stage</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, the first stage will downsample the inputs using a <code>stride</code> of 2.`,name:"downsample_in_first_stage"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/regnet/configuration_regnet.py#L28"}}),A=new Fe({props:{anchor:"transformers.RegNetConfig.example",$$slots:{default:[Le]},$$scope:{ctx:F}}}),_e=new Pe({props:{pytorch:!0,tensorflow:!0,jax:!0,$$slots:{jax:[lt],tensorflow:[tt],pytorch:[Se]},$$scope:{ctx:F}}}),{c(){e=g("meta"),c=l(),t=g("p"),n=l(),b(p.$$.fragment),s=l(),b(j.$$.fragment),ne=l(),C=g("p"),C.innerHTML=X,ae=l(),z=g("p"),z.textContent=be,oe=l(),Z=g("p"),Z.textContent=pe,P=l(),L=g("p"),L.innerHTML=Y,ee=l(),u=g("p"),u.innerHTML=H,re=l(),B=g("p"),B.innerHTML=ye,le=l(),b(k.$$.fragment),ce=l(),E=g("p"),E.textContent=U,V=l(),b(D.$$.fragment),R=l(),q=g("ul"),q.innerHTML=me,G=l(),te=g("p"),te.textContent=Q,S=l(),b(o.$$.fragment),h=l(),N=g("div"),b(J.$$.fragment),W=l(),K=g("p"),K.innerHTML=Ue,je=l(),ge=g("p"),ge.innerHTML=Ze,Ne=l(),b(A.$$.fragment),ue=l(),b(_e.$$.fragment),$e=l(),ve=g("p"),this.h()},l(a){const _=Ve("svelte-u9bgzb",document.head);e=f(_,"META",{name:!0,content:!0}),_.forEach(r),c=i(a),t=f(a,"P",{}),ie(t).forEach(r),n=i(a),y(p.$$.fragment,a),s=i(a),y(j.$$.fragment,a),ne=i(a),C=f(a,"P",{"data-svelte-h":!0}),x(C)!=="svelte-vy13p6"&&(C.innerHTML=X),ae=i(a),z=f(a,"P",{"data-svelte-h":!0}),x(z)!=="svelte-1y5hyhh"&&(z.textContent=be),oe=i(a),Z=f(a,"P",{"data-svelte-h":!0}),x(Z)!=="svelte-vfdo9a"&&(Z.textContent=pe),P=i(a),L=f(a,"P",{"data-svelte-h":!0}),x(L)!=="svelte-1judo2o"&&(L.innerHTML=Y),ee=i(a),u=f(a,"P",{"data-svelte-h":!0}),x(u)!=="svelte-vuzov4"&&(u.innerHTML=H),re=i(a),B=f(a,"P",{"data-svelte-h":!0}),x(B)!=="svelte-1bagpig"&&(B.innerHTML=ye),le=i(a),y(k.$$.fragment,a),ce=i(a),E=f(a,"P",{"data-svelte-h":!0}),x(E)!=="svelte-15k7oqe"&&(E.textContent=U),V=i(a),y(D.$$.fragment,a),R=i(a),q=f(a,"UL",{"data-svelte-h":!0}),x(q)!=="svelte-19u4l08"&&(q.innerHTML=me),G=i(a),te=f(a,"P",{"data-svelte-h":!0}),x(te)!=="svelte-1xesile"&&(te.textContent=Q),S=i(a),y(o.$$.fragment,a),h=i(a),N=f(a,"DIV",{class:!0});var O=ie(N);y(J.$$.fragment,O),W=i(O),K=f(O,"P",{"data-svelte-h":!0}),x(K)!=="svelte-1qp6bqk"&&(K.innerHTML=Ue),je=i(O),ge=f(O,"P",{"data-svelte-h":!0}),x(ge)!=="svelte-o55m63"&&(ge.innerHTML=Ze),Ne=i(O),y(A.$$.fragment,O),O.forEach(r),ue=i(a),y(_e.$$.fragment,a),$e=i(a),ve=f(a,"P",{}),ie(ve).forEach(r),this.h()},h(){de(e,"name","hf:doc:metadata"),de(e,"content",dt),de(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(a,_){d(document.head,e),m(a,c,_),m(a,t,_),m(a,n,_),$(p,a,_),m(a,s,_),$(j,a,_),m(a,ne,_),m(a,C,_),m(a,ae,_),m(a,z,_),m(a,oe,_),m(a,Z,_),m(a,P,_),m(a,L,_),m(a,ee,_),m(a,u,_),m(a,re,_),m(a,B,_),m(a,le,_),$(k,a,_),m(a,ce,_),m(a,E,_),m(a,V,_),$(D,a,_),m(a,R,_),m(a,q,_),m(a,G,_),m(a,te,_),m(a,S,_),$(o,a,_),m(a,h,_),m(a,N,_),$(J,N,null),d(N,W),d(N,K),d(N,je),d(N,ge),d(N,Ne),$(A,N,null),m(a,ue,_),$(_e,a,_),m(a,$e,_),m(a,ve,_),xe=!0},p(a,[_]){const O={};_&2&&(O.$$scope={dirty:_,ctx:a}),A.$set(O);const Ce={};_&2&&(Ce.$$scope={dirty:_,ctx:a}),_e.$set(Ce)},i(a){xe||(w(p.$$.fragment,a),w(j.$$.fragment,a),w(k.$$.fragment,a),w(D.$$.fragment,a),w(o.$$.fragment,a),w(J.$$.fragment,a),w(A.$$.fragment,a),w(_e.$$.fragment,a),xe=!0)},o(a){M(p.$$.fragment,a),M(j.$$.fragment,a),M(k.$$.fragment,a),M(D.$$.fragment,a),M(o.$$.fragment,a),M(J.$$.fragment,a),M(A.$$.fragment,a),M(_e.$$.fragment,a),xe=!1},d(a){a&&(r(c),r(t),r(n),r(s),r(ne),r(C),r(ae),r(z),r(oe),r(Z),r(P),r(L),r(ee),r(u),r(re),r(B),r(le),r(ce),r(E),r(V),r(R),r(q),r(G),r(te),r(S),r(h),r(N),r(ue),r($e),r(ve)),r(e),T(p,a),T(j,a),T(k,a),T(D,a),T(o,a),T(J),T(A),T(_e,a)}}}const dt='{"title":"RegNet","local":"regnet","sections":[{"title":"Overview","local":"overview","sections":[],"depth":2},{"title":"Resources","local":"resources","sections":[],"depth":2},{"title":"RegNetConfig","local":"transformers.RegNetConfig","sections":[],"depth":2},{"title":"RegNetModel","local":"transformers.RegNetModel","sections":[],"depth":2},{"title":"RegNetForImageClassification","local":"transformers.RegNetForImageClassification","sections":[],"depth":2},{"title":"TFRegNetModel","local":"transformers.TFRegNetModel","sections":[],"depth":2},{"title":"TFRegNetForImageClassification","local":"transformers.TFRegNetForImageClassification","sections":[],"depth":2},{"title":"FlaxRegNetModel","local":"transformers.FlaxRegNetModel","sections":[],"depth":2},{"title":"FlaxRegNetForImageClassification","local":"transformers.FlaxRegNetForImageClassification","sections":[],"depth":2}],"depth":1}';function ct(F){return Ge(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class $t extends ze{constructor(e){super(),Be(this,e,ct,it,ke,{})}}export{$t as component};
