import{s as so,o as io,n as Ze}from"../chunks/scheduler.9bc65507.js";import{S as co,i as lo,g as l,s as r,r as m,A as mo,h as d,f as o,c as a,j as w,u as h,x as _,k as S,y as i,a as s,v as p,d as f,t as u,w as g}from"../chunks/index.707bf1b6.js";import{T as Oe}from"../chunks/Tip.c2ecdbf4.js";import{D as z}from"../chunks/Docstring.17db21ae.js";import{C as ao}from"../chunks/CodeBlock.54a9f38d.js";import{E as ho}from"../chunks/ExampleCodeBlock.4f515aa9.js";import{H as D}from"../chunks/Heading.342b1fa6.js";function po(M){let n,x="Example:",c,T,F;return T=new ao({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFBhdGNoVFNNaXhlckNvbmZpZyUyQyUyMFBhdGNoVFNNaXhlck1vZGVsJTBBJTBBJTIzJTIwSW5pdGlhbGl6aW5nJTIwYSUyMGRlZmF1bHQlMjBQYXRjaFRTTWl4ZXIlMjBjb25maWd1cmF0aW9uJTBBY29uZmlndXJhdGlvbiUyMCUzRCUyMFBhdGNoVFNNaXhlckNvbmZpZygpJTBBJTBBJTIzJTIwUmFuZG9tbHklMjBpbml0aWFsaXppbmclMjBhJTIwbW9kZWwlMjAod2l0aCUyMHJhbmRvbSUyMHdlaWdodHMpJTIwZnJvbSUyMHRoZSUyMGNvbmZpZ3VyYXRpb24lMEFtb2RlbCUyMCUzRCUyMFBhdGNoVFNNaXhlck1vZGVsKGNvbmZpZ3VyYXRpb24pJTBBJTBBJTIzJTIwQWNjZXNzaW5nJTIwdGhlJTIwbW9kZWwlMjBjb25maWd1cmF0aW9uJTBBY29uZmlndXJhdGlvbiUyMCUzRCUyMG1vZGVsLmNvbmZpZw==",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> PatchTSMixerConfig, PatchTSMixerModel

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a default PatchTSMixer configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = PatchTSMixerConfig()

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Randomly initializing a model (with random weights) from the configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = PatchTSMixerModel(configuration)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Accessing the model configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = model.config`,wrap:!1}}),{c(){n=l("p"),n.textContent=x,c=r(),m(T.$$.fragment)},l(v){n=d(v,"P",{"data-svelte-h":!0}),_(n)!=="svelte-11lpom8"&&(n.textContent=x),c=a(v),h(T.$$.fragment,v)},m(v,y){s(v,n,y),s(v,c,y),p(T,v,y),F=!0},p:Ze,i(v){F||(f(T.$$.fragment,v),F=!0)},o(v){u(T.$$.fragment,v),F=!1},d(v){v&&(o(n),o(c)),g(T,v)}}}function fo(M){let n,x=`Although the recipe for forward pass needs to be defined within this function, one should call the <code>Module</code>
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`;return{c(){n=l("p"),n.innerHTML=x},l(c){n=d(c,"P",{"data-svelte-h":!0}),_(n)!=="svelte-fincs2"&&(n.innerHTML=x)},m(c,T){s(c,n,T)},p:Ze,d(c){c&&o(n)}}}function uo(M){let n,x=`Although the recipe for forward pass needs to be defined within this function, one should call the <code>Module</code>
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`;return{c(){n=l("p"),n.innerHTML=x},l(c){n=d(c,"P",{"data-svelte-h":!0}),_(n)!=="svelte-fincs2"&&(n.innerHTML=x)},m(c,T){s(c,n,T)},p:Ze,d(c){c&&o(n)}}}function go(M){let n,x=`Although the recipe for forward pass needs to be defined within this function, one should call the <code>Module</code>
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`;return{c(){n=l("p"),n.innerHTML=x},l(c){n=d(c,"P",{"data-svelte-h":!0}),_(n)!=="svelte-fincs2"&&(n.innerHTML=x)},m(c,T){s(c,n,T)},p:Ze,d(c){c&&o(n)}}}function _o(M){let n,x=`Although the recipe for forward pass needs to be defined within this function, one should call the <code>Module</code>
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`;return{c(){n=l("p"),n.innerHTML=x},l(c){n=d(c,"P",{"data-svelte-h":!0}),_(n)!=="svelte-fincs2"&&(n.innerHTML=x)},m(c,T){s(c,n,T)},p:Ze,d(c){c&&o(n)}}}function xo(M){let n,x=`Although the recipe for forward pass needs to be defined within this function, one should call the <code>Module</code>
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`;return{c(){n=l("p"),n.innerHTML=x},l(c){n=d(c,"P",{"data-svelte-h":!0}),_(n)!=="svelte-fincs2"&&(n.innerHTML=x)},m(c,T){s(c,n,T)},p:Ze,d(c){c&&o(n)}}}function To(M){let n,x,c,T,F,v,y,qe,Q,Wt='The PatchTSMixer model was proposed in <a href="https://arxiv.org/pdf/2306.09364.pdf" rel="nofollow">TSMixer: Lightweight MLP-Mixer Model for Multivariate Time Series Forecasting</a> by Vijay Ekambaram, Arindam Jati, Nam Nguyen, Phanwadee Sinthong and Jayant Kalagnanam.',Ee,Y,Dt="PatchTSMixer is a lightweight time-series modeling approach based on the MLP-Mixer architecture. In this HuggingFace implementation, we provide PatchTSMixer’s capabilities to effortlessly facilitate lightweight mixing across patches, channels, and hidden features for effective multivariate time-series modeling. It also supports various attention mechanisms starting from simple gated attention to more complex self-attention blocks that can be customized accordingly. The model can be pretrained and subsequently used for various downstream tasks such as forecasting, classification and regression.",Ge,K,Bt="The abstract from the paper is the following:",Ve,ee,Zt="<em>TSMixer is a lightweight neural architecture exclusively composed of multi-layer perceptron (MLP) modules designed for multivariate forecasting and representation learning on patched time series. Our model draws inspiration from the success of MLP-Mixer models in computer vision. We demonstrate the challenges involved in adapting Vision MLP-Mixer for time series and introduce empirically validated components to enhance accuracy. This includes a novel design paradigm of attaching online reconciliation heads to the MLP-Mixer backbone, for explicitly modeling the time-series properties such as hierarchy and channel-correlations. We also propose a Hybrid channel modeling approach to effectively handle noisy channel interactions and generalization across diverse datasets, a common challenge in existing patch channel-mixing methods. Additionally, a simple gated attention mechanism is introduced in the backbone to prioritize important features. By incorporating these lightweight components, we significantly enhance the learning capability of simple MLP structures, outperforming complex Transformer models with minimal computing usage. Moreover, TSMixer’s modular design enables compatibility with both supervised and masked self-supervised learning methods, making it a promising building block for time-series Foundation Models. TSMixer outperforms state-of-the-art MLP and Transformer models in forecasting by a considerable margin of 8-60%. It also outperforms the latest strong benchmarks of Patch-Transformer models (by 1-2%) with a significant reduction in memory and runtime (2-3X).</em>",Xe,te,jt=`This model was contributed by <a href="https://huggingface.co/ajati" rel="nofollow">ajati</a>, <a href="https://huggingface.co/vijaye12" rel="nofollow">vijaye12</a>,
<a href="https://huggingface.co/gsinthong" rel="nofollow">gsinthong</a>, <a href="https://huggingface.co/namctin" rel="nofollow">namctin</a>,
<a href="https://huggingface.co/wmgifford" rel="nofollow">wmgifford</a>, <a href="https://huggingface.co/kashif" rel="nofollow">kashif</a>.`,Ae,oe,Qe,ne,Ye,re,Ke,ae,Ot='The model can also be used for time series classification and time series regression. See the respective <a href="/docs/transformers/main/en/model_doc/patchtsmixer#transformers.PatchTSMixerForTimeSeriesClassification">PatchTSMixerForTimeSeriesClassification</a> and <a href="/docs/transformers/main/en/model_doc/patchtsmixer#transformers.PatchTSMixerForRegression">PatchTSMixerForRegression</a> classes.',et,se,tt,P,ie,ft,Pe,qt=`This is the configuration class to store the configuration of a <a href="/docs/transformers/main/en/model_doc/patchtsmixer#transformers.PatchTSMixerModel">PatchTSMixerModel</a>. It is used to instantiate a
PatchTSMixer model according to the specified arguments, defining the model architecture. Instantiating a
configuration with the defaults will yield a similar configuration to that of the PatchTSMixer
<a href="https://huggingface.co/ibm/patchtsmixer-etth1-pretrain" rel="nofollow">ibm/patchtsmixer-etth1-pretrain</a> architecture.`,ut,$e,Et=`Configuration objects inherit from <a href="/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig">PretrainedConfig</a> and can be used to control the model outputs. Read the
documentation from <a href="/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig">PretrainedConfig</a> for more information.`,gt,q,ot,ce,nt,b,le,_t,we,Gt="The PatchTSMixer Model for time-series forecasting.",xt,Se,Vt=`This model inherits from <a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel">PreTrainedModel</a>. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`,Tt,Fe,Xt=`This model is also a PyTorch <a href="https://pytorch.org/docs/stable/nn.html#torch.nn.Module" rel="nofollow">torch.nn.Module</a> subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`,vt,H,de,bt,ye,At='The <a href="/docs/transformers/main/en/model_doc/patchtsmixer#transformers.PatchTSMixerModel">PatchTSMixerModel</a> forward method, overrides the <code>__call__</code> special method.',Mt,E,rt,me,at,C,he,Pt,Ce,Qt="<code>PatchTSMixer</code> for forecasting application.",$t,I,pe,wt,ke,Yt='The <a href="/docs/transformers/main/en/model_doc/patchtsmixer#transformers.PatchTSMixerForPrediction">PatchTSMixerForPrediction</a> forward method, overrides the <code>__call__</code> special method.',St,G,st,fe,it,k,ue,Ft,Ne,Kt="<code>PatchTSMixer</code> for classification application.",yt,R,ge,Ct,Je,eo='The <a href="/docs/transformers/main/en/model_doc/patchtsmixer#transformers.PatchTSMixerForTimeSeriesClassification">PatchTSMixerForTimeSeriesClassification</a> forward method, overrides the <code>__call__</code> special method.',kt,V,ct,_e,lt,N,xe,Nt,Le,to="<code>PatchTSMixer</code> for mask pretraining.",Jt,U,Te,Lt,ze,oo='The <a href="/docs/transformers/main/en/model_doc/patchtsmixer#transformers.PatchTSMixerForPretraining">PatchTSMixerForPretraining</a> forward method, overrides the <code>__call__</code> special method.',zt,X,dt,ve,mt,J,be,Ht,He,no="<code>PatchTSMixer</code> for regression application.",It,W,Me,Rt,Ie,ro='The <a href="/docs/transformers/main/en/model_doc/patchtsmixer#transformers.PatchTSMixerForRegression">PatchTSMixerForRegression</a> forward method, overrides the <code>__call__</code> special method.',Ut,A,ht,je,pt;return F=new D({props:{title:"PatchTSMixer",local:"patchtsmixer",headingTag:"h1"}}),y=new D({props:{title:"Overview",local:"overview",headingTag:"h2"}}),oe=new D({props:{title:"Sample usage",local:"sample-usage",headingTag:"h2"}}),ne=new ao({props:{code:"JTBBZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFBhdGNoVFNNaXhlckNvbmZpZyUyQyUyMFBhdGNoVFNNaXhlckZvclByZWRpY3Rpb24lMEFmcm9tJTIwdHJhbnNmb3JtZXJzJTIwaW1wb3J0JTIwVHJhaW5lciUyQyUyMFRyYWluaW5nQXJndW1lbnRzJTJDJTBBJTBBJTBBY29uZmlnJTIwJTNEJTIwUGF0Y2hUU01peGVyQ29uZmlnKGNvbnRleHRfbGVuZ3RoJTIwJTNEJTIwNTEyJTJDJTIwcHJlZGljdGlvbl9sZW5ndGglMjAlM0QlMjA5NiklMEFtb2RlbCUyMCUzRCUyMFBhdGNoVFNNaXhlckZvclByZWRpY3Rpb24oY29uZmlnKSUwQXRyYWluZXIlMjAlM0QlMjBUcmFpbmVyKG1vZGVsJTNEbW9kZWwlMkMlMjBhcmdzJTNEdHJhaW5pbmdfYXJncyUyQyUyMCUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMHRyYWluX2RhdGFzZXQlM0R0cmFpbl9kYXRhc2V0JTJDJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwZXZhbF9kYXRhc2V0JTNEdmFsaWRfZGF0YXNldCklMEF0cmFpbmVyLnRyYWluKCklMEFyZXN1bHRzJTIwJTNEJTIwdHJhaW5lci5ldmFsdWF0ZSh0ZXN0X2RhdGFzZXQp",highlighted:`
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> PatchTSMixerConfig, PatchTSMixerForPrediction
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Trainer, TrainingArguments,


config = PatchTSMixerConfig(context_length = <span class="hljs-number">512</span>, prediction_length = <span class="hljs-number">96</span>)
model = PatchTSMixerForPrediction(config)
trainer = Trainer(model=model, args=training_args, 
            train_dataset=train_dataset,
            eval_dataset=valid_dataset)
trainer.train()
results = trainer.evaluate(test_dataset)`,wrap:!1}}),re=new D({props:{title:"Usage tips",local:"usage-tips",headingTag:"h2"}}),se=new D({props:{title:"PatchTSMixerConfig",local:"transformers.PatchTSMixerConfig",headingTag:"h2"}}),ie=new z({props:{name:"class transformers.PatchTSMixerConfig",anchor:"transformers.PatchTSMixerConfig",parameters:[{name:"context_length",val:": int = 32"},{name:"patch_length",val:": int = 8"},{name:"num_input_channels",val:": int = 1"},{name:"patch_stride",val:": int = 8"},{name:"num_parallel_samples",val:": int = 100"},{name:"d_model",val:": int = 8"},{name:"expansion_factor",val:": int = 2"},{name:"num_layers",val:": int = 3"},{name:"dropout",val:": float = 0.2"},{name:"mode",val:": str = 'common_channel'"},{name:"gated_attn",val:": bool = True"},{name:"norm_mlp",val:": str = 'LayerNorm'"},{name:"self_attn",val:": bool = False"},{name:"self_attn_heads",val:": int = 1"},{name:"use_positional_encoding",val:": bool = False"},{name:"positional_encoding_type",val:": str = 'sincos'"},{name:"scaling",val:": Union = 'std'"},{name:"loss",val:": str = 'mse'"},{name:"init_std",val:": float = 0.02"},{name:"post_init",val:": bool = False"},{name:"norm_eps",val:": float = 1e-05"},{name:"mask_type",val:": str = 'random'"},{name:"random_mask_ratio",val:": float = 0.5"},{name:"num_forecast_mask_patches",val:": Union = [2]"},{name:"mask_value",val:": int = 0"},{name:"masked_loss",val:": bool = True"},{name:"channel_consistent_masking",val:": bool = True"},{name:"unmasked_channel_indices",val:": Optional = None"},{name:"head_dropout",val:": float = 0.2"},{name:"distribution_output",val:": str = 'student_t'"},{name:"prediction_length",val:": int = 16"},{name:"prediction_channel_indices",val:": list = None"},{name:"num_targets",val:": int = 3"},{name:"output_range",val:": list = None"},{name:"head_aggregation",val:": str = 'max_pool'"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.PatchTSMixerConfig.context_length",description:`<strong>context_length</strong> (<code>int</code>, <em>optional</em>, defaults to 32) &#x2014;
The context/history length for the input sequence.`,name:"context_length"},{anchor:"transformers.PatchTSMixerConfig.patch_length",description:`<strong>patch_length</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
The patch length for the input sequence.`,name:"patch_length"},{anchor:"transformers.PatchTSMixerConfig.num_input_channels",description:`<strong>num_input_channels</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
Number of input variates. For Univariate, set it to 1.`,name:"num_input_channels"},{anchor:"transformers.PatchTSMixerConfig.patch_stride",description:`<strong>patch_stride</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
Determines the overlap between two consecutive patches. Set it to patch_length (or greater), if we want
non-overlapping patches.`,name:"patch_stride"},{anchor:"transformers.PatchTSMixerConfig.num_parallel_samples",description:`<strong>num_parallel_samples</strong> (<code>int</code>, <em>optional</em>, defaults to 100) &#x2014;
The number of samples to generate in parallel for probabilistic forecast.`,name:"num_parallel_samples"},{anchor:"transformers.PatchTSMixerConfig.d_model",description:`<strong>d_model</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
Hidden dimension of the model. Recommended to set it as a multiple of patch_length (i.e. 2-5X of
patch_length). Larger value indicates more complex model.`,name:"d_model"},{anchor:"transformers.PatchTSMixerConfig.expansion_factor",description:`<strong>expansion_factor</strong> (<code>int</code>, <em>optional</em>, defaults to 2) &#x2014;
Expansion factor to use inside MLP. Recommended range is 2-5. Larger value indicates more complex model.`,name:"expansion_factor"},{anchor:"transformers.PatchTSMixerConfig.num_layers",description:`<strong>num_layers</strong> (<code>int</code>, <em>optional</em>, defaults to 3) &#x2014;
Number of layers to use. Recommended range is 3-15. Larger value indicates more complex model.`,name:"num_layers"},{anchor:"transformers.PatchTSMixerConfig.dropout",description:`<strong>dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.2) &#x2014;
The dropout probability the <code>PatchTSMixer</code> backbone. Recommended range is 0.2-0.7`,name:"dropout"},{anchor:"transformers.PatchTSMixerConfig.mode",description:`<strong>mode</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;common_channel&quot;</code>) &#x2014;
Mixer Mode. Determines how to process the channels. Allowed values: &#x201C;common_channel&#x201D;, &#x201C;mix_channel&#x201D;. In
&#x201C;common_channel&#x201D; mode, we follow Channel-independent modelling with no explicit channel-mixing. Channel
mixing happens in an implicit manner via shared weights across channels. (preferred first approach) In
&#x201C;mix_channel&#x201D; mode, we follow explicit channel-mixing in addition to patch and feature mixer. (preferred
approach when channel correlations are very important to model)`,name:"mode"},{anchor:"transformers.PatchTSMixerConfig.gated_attn",description:`<strong>gated_attn</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Enable Gated Attention.`,name:"gated_attn"},{anchor:"transformers.PatchTSMixerConfig.norm_mlp",description:`<strong>norm_mlp</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;LayerNorm&quot;</code>) &#x2014;
Normalization layer (BatchNorm or LayerNorm).`,name:"norm_mlp"},{anchor:"transformers.PatchTSMixerConfig.self_attn",description:`<strong>self_attn</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Enable Tiny self attention across patches. This can be enabled when the output of Vanilla PatchTSMixer with
gated attention is not satisfactory. Enabling this leads to explicit pair-wise attention and modelling
across patches.`,name:"self_attn"},{anchor:"transformers.PatchTSMixerConfig.self_attn_heads",description:`<strong>self_attn_heads</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
Number of self-attention heads. Works only when <code>self_attn</code> is set to <code>True</code>.`,name:"self_attn_heads"},{anchor:"transformers.PatchTSMixerConfig.use_positional_encoding",description:`<strong>use_positional_encoding</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Enable the use of positional embedding for the tiny self-attention layers. Works only when <code>self_attn</code> is
set to <code>True</code>.`,name:"use_positional_encoding"},{anchor:"transformers.PatchTSMixerConfig.positional_encoding_type",description:`<strong>positional_encoding_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;sincos&quot;</code>) &#x2014;
Positional encodings. Options <code>&quot;random&quot;</code> and <code>&quot;sincos&quot;</code> are supported. Works only when
<code>use_positional_encoding</code> is set to <code>True</code>`,name:"positional_encoding_type"},{anchor:"transformers.PatchTSMixerConfig.scaling",description:`<strong>scaling</strong> (<code>string</code> or <code>bool</code>, <em>optional</em>, defaults to <code>&quot;std&quot;</code>) &#x2014;
Whether to scale the input targets via &#x201C;mean&#x201D; scaler, &#x201C;std&#x201D; scaler or no scaler if <code>None</code>. If <code>True</code>, the
scaler is set to &#x201C;mean&#x201D;.`,name:"scaling"},{anchor:"transformers.PatchTSMixerConfig.loss",description:`<strong>loss</strong> (<code>string</code>, <em>optional</em>, defaults to <code>&quot;mse&quot;</code>) &#x2014;
The loss function for the model corresponding to the <code>distribution_output</code> head. For parametric
distributions it is the negative log likelihood (&#x201C;nll&#x201D;) and for point estimates it is the mean squared
error &#x201C;mse&#x201D;.`,name:"loss"},{anchor:"transformers.PatchTSMixerConfig.init_std",description:`<strong>init_std</strong> (<code>float</code>, <em>optional</em>, defaults to 0.02) &#x2014;
The standard deviation of the truncated normal weight initialization distribution.`,name:"init_std"},{anchor:"transformers.PatchTSMixerConfig.post_init",description:`<strong>post_init</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to use custom weight initialization from <code>transformers</code> library, or the default initialization in
<code>PyTorch</code>. Setting it to <code>False</code> performs <code>PyTorch</code> weight initialization.`,name:"post_init"},{anchor:"transformers.PatchTSMixerConfig.norm_eps",description:`<strong>norm_eps</strong> (<code>float</code>, <em>optional</em>, defaults to 1e-05) &#x2014;
A value added to the denominator for numerical stability of normalization.`,name:"norm_eps"},{anchor:"transformers.PatchTSMixerConfig.mask_type",description:`<strong>mask_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;random&quot;</code>) &#x2014;
Type of masking to use for Masked Pretraining mode. Allowed values are &#x201C;random&#x201D;, &#x201C;forecast&#x201D;. In Random
masking, points are masked randomly. In Forecast masking, points are masked towards the end.`,name:"mask_type"},{anchor:"transformers.PatchTSMixerConfig.random_mask_ratio",description:`<strong>random_mask_ratio</strong> (<code>float</code>, <em>optional</em>, defaults to 0.5) &#x2014;
Masking ratio to use when <code>mask_type</code> is <code>random</code>. Higher value indicates more masking.`,name:"random_mask_ratio"},{anchor:"transformers.PatchTSMixerConfig.num_forecast_mask_patches",description:`<strong>num_forecast_mask_patches</strong> (<code>int</code> or <code>list</code>, <em>optional</em>, defaults to <code>[2]</code>) &#x2014;
Number of patches to be masked at the end of each batch sample. If it is an integer, all the samples in the
batch will have the same number of masked patches. If it is a list, samples in the batch will be randomly
masked by numbers defined in the list. This argument is only used for forecast pretraining.`,name:"num_forecast_mask_patches"},{anchor:"transformers.PatchTSMixerConfig.mask_value",description:`<strong>mask_value</strong> (<code>float</code>, <em>optional</em>, defaults to <code>0.0</code>) &#x2014;
Mask value to use.`,name:"mask_value"},{anchor:"transformers.PatchTSMixerConfig.masked_loss",description:`<strong>masked_loss</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to compute pretraining loss only at the masked portions, or on the entire output.`,name:"masked_loss"},{anchor:"transformers.PatchTSMixerConfig.channel_consistent_masking",description:`<strong>channel_consistent_masking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
When true, masking will be same across all channels of a timeseries. Otherwise, masking positions will vary
across channels.`,name:"channel_consistent_masking"},{anchor:"transformers.PatchTSMixerConfig.unmasked_channel_indices",description:`<strong>unmasked_channel_indices</strong> (<code>list</code>, <em>optional</em>) &#x2014;
Channels that are not masked during pretraining.`,name:"unmasked_channel_indices"},{anchor:"transformers.PatchTSMixerConfig.head_dropout",description:`<strong>head_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.2) &#x2014;
The dropout probability the <code>PatchTSMixer</code> head.`,name:"head_dropout"},{anchor:"transformers.PatchTSMixerConfig.distribution_output",description:`<strong>distribution_output</strong> (<code>string</code>, <em>optional</em>, defaults to <code>&quot;student_t&quot;</code>) &#x2014;
The distribution emission head for the model when loss is &#x201C;nll&#x201D;. Could be either &#x201C;student_t&#x201D;, &#x201C;normal&#x201D; or
&#x201C;negative_binomial&#x201D;.`,name:"distribution_output"},{anchor:"transformers.PatchTSMixerConfig.prediction_length",description:`<strong>prediction_length</strong> (<code>int</code>, <em>optional</em>, defaults to 16) &#x2014;
Number of time steps to forecast for a forecasting task. Also known as the Forecast Horizon.`,name:"prediction_length"},{anchor:"transformers.PatchTSMixerConfig.prediction_channel_indices",description:`<strong>prediction_channel_indices</strong> (<code>list</code>, <em>optional</em>) &#x2014;
List of channel indices to forecast. If None, forecast all channels. Target data is expected to have all
channels and we explicitly filter the channels in prediction and target before loss computation.`,name:"prediction_channel_indices"},{anchor:"transformers.PatchTSMixerConfig.num_targets",description:`<strong>num_targets</strong> (<code>int</code>, <em>optional</em>, defaults to 3) &#x2014;
Number of targets (dimensionality of the regressed variable) for a regression task.`,name:"num_targets"},{anchor:"transformers.PatchTSMixerConfig.output_range",description:`<strong>output_range</strong> (<code>list</code>, <em>optional</em>) &#x2014;
Output range to restrict for the regression task. Defaults to None.`,name:"output_range"},{anchor:"transformers.PatchTSMixerConfig.head_aggregation",description:`<strong>head_aggregation</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;max_pool&quot;</code>) &#x2014;
Aggregation mode to enable for classification or regression task. Allowed values are <code>None</code>, &#x201C;use_last&#x201D;,
&#x201C;max_pool&#x201D;, &#x201C;avg_pool&#x201D;.`,name:"head_aggregation"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/patchtsmixer/configuration_patchtsmixer.py#L30"}}),q=new ho({props:{anchor:"transformers.PatchTSMixerConfig.example",$$slots:{default:[po]},$$scope:{ctx:M}}}),ce=new D({props:{title:"PatchTSMixerModel",local:"transformers.PatchTSMixerModel",headingTag:"h2"}}),le=new z({props:{name:"class transformers.PatchTSMixerModel",anchor:"transformers.PatchTSMixerModel",parameters:[{name:"config",val:": PatchTSMixerConfig"},{name:"mask_input",val:": bool = False"}],parametersDescription:[{anchor:"transformers.PatchTSMixerModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/main/en/model_doc/patchtsmixer#transformers.PatchTSMixerConfig">PatchTSMixerConfig</a>) &#x2014;
Model configuration class with all the parameters of the model. Initializing with a config file does not
load the weights associated with the model, only the configuration. Check out the
<a href="/docs/transformers/main/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"},{anchor:"transformers.PatchTSMixerModel.mask_input",description:`<strong>mask_input</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If True, Masking will be enabled. False otherwise.`,name:"mask_input"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/patchtsmixer/modeling_patchtsmixer.py#L1299"}}),de=new z({props:{name:"forward",anchor:"transformers.PatchTSMixerModel.forward",parameters:[{name:"past_values",val:": Tensor"},{name:"observed_mask",val:": Optional = None"},{name:"output_hidden_states",val:": Optional = False"},{name:"return_dict",val:": Optional = None"}],parametersDescription:[{anchor:"transformers.PatchTSMixerModel.forward.past_values",description:`<strong>past_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, seq_length, num_input_channels)</code>) &#x2014;
Context values of the time series. For a pretraining task, this denotes the input time series to predict
the masked portion. For a forecasting task, this denotes the history/past time series values. Similarly,
for classification or regression tasks, it denotes the appropriate context values of the time series.</p>
<p>For univariate time series, <code>num_input_channels</code> dimension should be 1. For multivariate time series, it is
greater than 1.`,name:"past_values"},{anchor:"transformers.PatchTSMixerModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers.`,name:"output_hidden_states"},{anchor:"transformers.PatchTSMixerModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.PatchTSMixerModel.forward.observed_mask",description:`<strong>observed_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, num_input_channels)</code>, <em>optional</em>) &#x2014;
Boolean mask to indicate which <code>past_values</code> were observed and which were missing. Mask values selected
in <code>[0, 1]</code>:</p>
<ul>
<li>1 for values that are <strong>observed</strong>,</li>
<li>0 for values that are <strong>missing</strong> (i.e. NaNs that were replaced by zeros).</li>
</ul>`,name:"observed_mask"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/patchtsmixer/modeling_patchtsmixer.py#L1327",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>A <code>transformers.models.patchtsmixer.modeling_patchtsmixer.PatchTSMixerModelOutput</code> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/patchtsmixer#transformers.PatchTSMixerConfig"
>PatchTSMixerConfig</a>) and inputs.</p>
<ul>
<li><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code>  of shape <code>(batch_size, num_channels, num_patches, d_model)</code>) — Hidden-state at the output of the last layer of the model.</li>
<li><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>) — Hidden-states of the model at the output of each layer.</li>
<li><strong>patch_input</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, num_patches, patch_length)</code>) — Patched input data to the model.</li>
<li><strong>mask:</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, num_patches)</code>,<em>optional</em>) — Bool Tensor indicating True in masked patches and False otherwise.</li>
<li><strong>loc:</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, 1, num_channels)</code>,<em>optional</em>) — Gives the mean of the context window per channel. Used for revin denorm outside the model, if revin
enabled.</li>
<li><strong>scale:</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, 1, num_channels)</code>,<em>optional</em>) — Gives the std dev of the context window per channel. Used for revin denorm outside the model, if revin
enabled.</li>
</ul>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>transformers.models.patchtsmixer.modeling_patchtsmixer.PatchTSMixerModelOutput</code> or <code>tuple(torch.FloatTensor)</code></p>
`}}),E=new Oe({props:{$$slots:{default:[fo]},$$scope:{ctx:M}}}),me=new D({props:{title:"PatchTSMixerForPrediction",local:"transformers.PatchTSMixerForPrediction",headingTag:"h2"}}),he=new z({props:{name:"class transformers.PatchTSMixerForPrediction",anchor:"transformers.PatchTSMixerForPrediction",parameters:[{name:"config",val:": PatchTSMixerConfig"}],parametersDescription:[{anchor:"transformers.PatchTSMixerForPrediction.config",description:`<strong>config</strong> (<code>PatchTSMixerConfig</code>, <em>required</em>) &#x2014;
Configuration.`,name:"config"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/patchtsmixer/modeling_patchtsmixer.py#L1597",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>None</code>.</p>
`}}),pe=new z({props:{name:"forward",anchor:"transformers.PatchTSMixerForPrediction.forward",parameters:[{name:"past_values",val:": Tensor"},{name:"observed_mask",val:": Optional = None"},{name:"future_values",val:": Optional = None"},{name:"output_hidden_states",val:": Optional = False"},{name:"return_loss",val:": bool = True"},{name:"return_dict",val:": Optional = None"}],parametersDescription:[{anchor:"transformers.PatchTSMixerForPrediction.forward.past_values",description:`<strong>past_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, seq_length, num_input_channels)</code>) &#x2014;
Context values of the time series. For a pretraining task, this denotes the input time series to predict
the masked portion. For a forecasting task, this denotes the history/past time series values. Similarly,
for classification or regression tasks, it denotes the appropriate context values of the time series.</p>
<p>For univariate time series, <code>num_input_channels</code> dimension should be 1. For multivariate time series, it is
greater than 1.`,name:"past_values"},{anchor:"transformers.PatchTSMixerForPrediction.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers.`,name:"output_hidden_states"},{anchor:"transformers.PatchTSMixerForPrediction.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.PatchTSMixerForPrediction.forward.observed_mask",description:`<strong>observed_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, num_input_channels)</code>, <em>optional</em>) &#x2014;
Boolean mask to indicate which <code>past_values</code> were observed and which were missing. Mask values selected
in <code>[0, 1]</code>:</p>
<ul>
<li>1 for values that are <strong>observed</strong>,</li>
<li>0 for values that are <strong>missing</strong> (i.e. NaNs that were replaced by zeros).</li>
</ul>`,name:"observed_mask"},{anchor:"transformers.PatchTSMixerForPrediction.forward.future_values",description:`<strong>future_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, target_len, num_input_channels)</code> for forecasting, &#x2014;
<code>(batch_size, num_targets)</code> for regression, or <code>(batch_size,)</code> for classification, <em>optional</em>): Target
values of the time series, that serve as labels for the model. The <code>future_values</code> is what the
Transformer needs during training to learn to output, given the <code>past_values</code>. Note that, this is NOT
required for a pretraining task.</p>
<p>For a forecasting task, the shape is be <code>(batch_size, target_len, num_input_channels)</code>. Even if we want
to forecast only specific channels by setting the indices in <code>prediction_channel_indices</code> parameter,
pass the target data with all channels, as channel Filtering for both prediction and target will be
manually applied before the loss computation.`,name:"future_values"},{anchor:"transformers.PatchTSMixerForPrediction.forward.return_loss",description:`<strong>return_loss</strong> (<code>bool</code>,  <em>optional</em>) &#x2014;
Whether to return the loss in the <code>forward</code> call.`,name:"return_loss"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/patchtsmixer/modeling_patchtsmixer.py#L1641",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>A <code>transformers.models.patchtsmixer.modeling_patchtsmixer.PatchTSMixerForPredictionOutput</code> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/patchtsmixer#transformers.PatchTSMixerConfig"
>PatchTSMixerConfig</a>) and inputs.</p>
<ul>
<li><strong>prediction_outputs</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, prediction_length, num_input_channels)</code>) — Prediction output from the forecast head.</li>
<li><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_input_channels, num_patches, d_model)</code>) — Backbone embeddings before passing through the head.</li>
<li><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>) — Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</li>
<li><strong>loss</strong> (<em>optional</em>, returned when <code>y</code> is provided, <code>torch.FloatTensor</code> of shape <code>()</code>) — Total loss.</li>
<li><strong>loc</strong> (<code>torch.FloatTensor</code>, <em>optional</em> of shape <code>(batch_size, 1, num_input_channels)</code>) — Input mean</li>
<li><strong>scale</strong> (<code>torch.FloatTensor</code>, <em>optional</em> of shape <code>(batch_size, 1, num_input_channels)</code>) — Input std dev</li>
</ul>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>transformers.models.patchtsmixer.modeling_patchtsmixer.PatchTSMixerForPredictionOutput</code> or <code>tuple(torch.FloatTensor)</code></p>
`}}),G=new Oe({props:{$$slots:{default:[uo]},$$scope:{ctx:M}}}),fe=new D({props:{title:"PatchTSMixerForTimeSeriesClassification",local:"transformers.PatchTSMixerForTimeSeriesClassification",headingTag:"h2"}}),ue=new z({props:{name:"class transformers.PatchTSMixerForTimeSeriesClassification",anchor:"transformers.PatchTSMixerForTimeSeriesClassification",parameters:[{name:"config",val:": PatchTSMixerConfig"}],parametersDescription:[{anchor:"transformers.PatchTSMixerForTimeSeriesClassification.config",description:`<strong>config</strong> (<code>PatchTSMixerConfig</code>, <em>required</em>) &#x2014;
Configuration.`,name:"config"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/patchtsmixer/modeling_patchtsmixer.py#L1830",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>None</code>.</p>
`}}),ge=new z({props:{name:"forward",anchor:"transformers.PatchTSMixerForTimeSeriesClassification.forward",parameters:[{name:"past_values",val:": Tensor"},{name:"target_values",val:": Tensor = None"},{name:"output_hidden_states",val:": Optional = False"},{name:"return_loss",val:": bool = True"},{name:"return_dict",val:": Optional = None"}],parametersDescription:[{anchor:"transformers.PatchTSMixerForTimeSeriesClassification.forward.past_values",description:`<strong>past_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, seq_length, num_input_channels)</code>) &#x2014;
Context values of the time series. For a pretraining task, this denotes the input time series to predict
the masked portion. For a forecasting task, this denotes the history/past time series values. Similarly,
for classification or regression tasks, it denotes the appropriate context values of the time series.</p>
<p>For univariate time series, <code>num_input_channels</code> dimension should be 1. For multivariate time series, it is
greater than 1.`,name:"past_values"},{anchor:"transformers.PatchTSMixerForTimeSeriesClassification.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers.`,name:"output_hidden_states"},{anchor:"transformers.PatchTSMixerForTimeSeriesClassification.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.PatchTSMixerForTimeSeriesClassification.forward.target_values",description:`<strong>target_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, target_len, num_input_channels)</code> for forecasting, &#x2014;
<code>(batch_size, num_targets)</code> for regression, or <code>(batch_size,)</code> for classification, <em>optional</em>): Target
values of the time series, that serve as labels for the model. The <code>target_values</code> is what the
Transformer needs during training to learn to output, given the <code>past_values</code>. Note that, this is NOT
required for a pretraining task.</p>
<p>For a forecasting task, the shape is be <code>(batch_size, target_len, num_input_channels)</code>. Even if we want
to forecast only specific channels by setting the indices in <code>prediction_channel_indices</code> parameter,
pass the target data with all channels, as channel Filtering for both prediction and target will be
manually applied before the loss computation.</p>
<p>For a classification task, it has a shape of <code>(batch_size,)</code>.</p>
<p>For a regression task, it has a shape of <code>(batch_size, num_targets)</code>.`,name:"target_values"},{anchor:"transformers.PatchTSMixerForTimeSeriesClassification.forward.return_loss",description:`<strong>return_loss</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether to return the loss in the <code>forward</code> call.`,name:"return_loss"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/patchtsmixer/modeling_patchtsmixer.py#L1859",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>A <code>transformers.models.patchtsmixer.modeling_patchtsmixer.PatchTSMixerForTimeSeriesClassificationOutput</code> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/patchtsmixer#transformers.PatchTSMixerConfig"
>PatchTSMixerConfig</a>) and inputs.</p>
<ul>
<li><strong>prediction_outputs</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_labels)</code>) — Prediction output from the classfication head.</li>
<li><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_input_channels, num_patches, d_model)</code>) — Backbone embeddings before passing through the head.</li>
<li><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>) — Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</li>
<li><strong>loss</strong> (<em>optional</em>, returned when <code>y</code> is provided, <code>torch.FloatTensor</code> of shape <code>()</code>) — Total loss.</li>
</ul>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>transformers.models.patchtsmixer.modeling_patchtsmixer.PatchTSMixerForTimeSeriesClassificationOutput</code> or <code>tuple(torch.FloatTensor)</code></p>
`}}),V=new Oe({props:{$$slots:{default:[go]},$$scope:{ctx:M}}}),_e=new D({props:{title:"PatchTSMixerForPretraining",local:"transformers.PatchTSMixerForPretraining",headingTag:"h2"}}),xe=new z({props:{name:"class transformers.PatchTSMixerForPretraining",anchor:"transformers.PatchTSMixerForPretraining",parameters:[{name:"config",val:": PatchTSMixerConfig"}],parametersDescription:[{anchor:"transformers.PatchTSMixerForPretraining.config",description:`<strong>config</strong> (<code>PatchTSMixerConfig</code>, <em>required</em>) &#x2014;
Configuration.`,name:"config"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/patchtsmixer/modeling_patchtsmixer.py#L1415",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>None</code>.</p>
`}}),Te=new z({props:{name:"forward",anchor:"transformers.PatchTSMixerForPretraining.forward",parameters:[{name:"past_values",val:": Tensor"},{name:"observed_mask",val:": Optional = None"},{name:"output_hidden_states",val:": Optional = False"},{name:"return_loss",val:": bool = True"},{name:"return_dict",val:": Optional = None"}],parametersDescription:[{anchor:"transformers.PatchTSMixerForPretraining.forward.past_values",description:`<strong>past_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, seq_length, num_input_channels)</code>) &#x2014;
Context values of the time series. For a pretraining task, this denotes the input time series to predict
the masked portion. For a forecasting task, this denotes the history/past time series values. Similarly,
for classification or regression tasks, it denotes the appropriate context values of the time series.</p>
<p>For univariate time series, <code>num_input_channels</code> dimension should be 1. For multivariate time series, it is
greater than 1.`,name:"past_values"},{anchor:"transformers.PatchTSMixerForPretraining.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers.`,name:"output_hidden_states"},{anchor:"transformers.PatchTSMixerForPretraining.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.PatchTSMixerForPretraining.forward.observed_mask",description:`<strong>observed_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, num_input_channels)</code>, <em>optional</em>) &#x2014;
Boolean mask to indicate which <code>past_values</code> were observed and which were missing. Mask values selected
in <code>[0, 1]</code>:</p>
<ul>
<li>1 for values that are <strong>observed</strong>,</li>
<li>0 for values that are <strong>missing</strong> (i.e. NaNs that were replaced by zeros).</li>
</ul>`,name:"observed_mask"},{anchor:"transformers.PatchTSMixerForPretraining.forward.return_loss",description:`<strong>return_loss</strong> (<code>bool</code>,  <em>optional</em>) &#x2014;
Whether to return the loss in the <code>forward</code> call.`,name:"return_loss"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/patchtsmixer/modeling_patchtsmixer.py#L1438",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>A <code>transformers.models.patchtsmixer.modeling_patchtsmixer.PatchTSMixerForPreTrainingOutput</code> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/patchtsmixer#transformers.PatchTSMixerConfig"
>PatchTSMixerConfig</a>) and inputs.</p>
<ul>
<li><strong>prediction_outputs</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_input_channels, num_patches, patch_length)</code>) — Prediction output from the pretrain head.</li>
<li><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>) — Hidden-states of the model at the output of each layer.</li>
<li><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_input_channels, num_patches, d_model)</code>) — Backbone embeddings before passing through the head.</li>
<li><strong>loss</strong> (<em>optional</em>, returned when <code>y</code> is provided, <code>torch.FloatTensor</code> of shape <code>()</code>) — Total loss</li>
</ul>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>transformers.models.patchtsmixer.modeling_patchtsmixer.PatchTSMixerForPreTrainingOutput</code> or <code>tuple(torch.FloatTensor)</code></p>
`}}),X=new Oe({props:{$$slots:{default:[_o]},$$scope:{ctx:M}}}),ve=new D({props:{title:"PatchTSMixerForRegression",local:"transformers.PatchTSMixerForRegression",headingTag:"h2"}}),be=new z({props:{name:"class transformers.PatchTSMixerForRegression",anchor:"transformers.PatchTSMixerForRegression",parameters:[{name:"config",val:": PatchTSMixerConfig"}],parametersDescription:[{anchor:"transformers.PatchTSMixerForRegression.config",description:`<strong>config</strong> (<code>PatchTSMixerConfig</code>, <em>required</em>) &#x2014;
Configuration.`,name:"config"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/patchtsmixer/modeling_patchtsmixer.py#L2001",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>None</code>.</p>
`}}),Me=new z({props:{name:"forward",anchor:"transformers.PatchTSMixerForRegression.forward",parameters:[{name:"past_values",val:": Tensor"},{name:"target_values",val:": Tensor = None"},{name:"output_hidden_states",val:": Optional = False"},{name:"return_loss",val:": bool = True"},{name:"return_dict",val:": Optional = None"}],parametersDescription:[{anchor:"transformers.PatchTSMixerForRegression.forward.past_values",description:`<strong>past_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, seq_length, num_input_channels)</code>) &#x2014;
Context values of the time series. For a pretraining task, this denotes the input time series to predict
the masked portion. For a forecasting task, this denotes the history/past time series values. Similarly,
for classification or regression tasks, it denotes the appropriate context values of the time series.</p>
<p>For univariate time series, <code>num_input_channels</code> dimension should be 1. For multivariate time series, it is
greater than 1.`,name:"past_values"},{anchor:"transformers.PatchTSMixerForRegression.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers.`,name:"output_hidden_states"},{anchor:"transformers.PatchTSMixerForRegression.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/main/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.PatchTSMixerForRegression.forward.target_values",description:`<strong>target_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, target_len, num_input_channels)</code> for forecasting, &#x2014;
<code>(batch_size, num_targets)</code> for regression, or <code>(batch_size,)</code> for classification, <em>optional</em>): Target
values of the time series, that serve as labels for the model. The <code>target_values</code> is what the
Transformer needs during training to learn to output, given the <code>past_values</code>. Note that, this is NOT
required for a pretraining task.</p>
<p>For a forecasting task, the shape is be <code>(batch_size, target_len, num_input_channels)</code>. Even if we want
to forecast only specific channels by setting the indices in <code>prediction_channel_indices</code> parameter,
pass the target data with all channels, as channel Filtering for both prediction and target will be
manually applied before the loss computation.</p>
<p>For a classification task, it has a shape of <code>(batch_size,)</code>.</p>
<p>For a regression task, it has a shape of <code>(batch_size, num_targets)</code>.`,name:"target_values"},{anchor:"transformers.PatchTSMixerForRegression.forward.return_loss",description:`<strong>return_loss</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether to return the loss in the <code>forward</code> call.`,name:"return_loss"}],source:"https://github.com/QubitPi/huggingface-transformers/blob/main/src/transformers/models/patchtsmixer/modeling_patchtsmixer.py#L2052",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>A <code>transformers.models.patchtsmixer.modeling_patchtsmixer.PatchTSMixerForRegressionOutput</code> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/main/en/model_doc/patchtsmixer#transformers.PatchTSMixerConfig"
>PatchTSMixerConfig</a>) and inputs.</p>
<ul>
<li><strong>regression_outputs</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_targets)</code>) — Prediction output from the regression head.</li>
<li><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_input_channels, num_patches, d_model)</code>) — Backbone embeddings before passing through the head.</li>
<li><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>) — Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</li>
<li><strong>loss</strong> (<em>optional</em>, returned when <code>y</code> is provided, <code>torch.FloatTensor</code> of shape <code>()</code>) — Total loss.</li>
</ul>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>transformers.models.patchtsmixer.modeling_patchtsmixer.PatchTSMixerForRegressionOutput</code> or <code>tuple(torch.FloatTensor)</code></p>
`}}),A=new Oe({props:{$$slots:{default:[xo]},$$scope:{ctx:M}}}),{c(){n=l("meta"),x=r(),c=l("p"),T=r(),m(F.$$.fragment),v=r(),m(y.$$.fragment),qe=r(),Q=l("p"),Q.innerHTML=Wt,Ee=r(),Y=l("p"),Y.textContent=Dt,Ge=r(),K=l("p"),K.textContent=Bt,Ve=r(),ee=l("p"),ee.innerHTML=Zt,Xe=r(),te=l("p"),te.innerHTML=jt,Ae=r(),m(oe.$$.fragment),Qe=r(),m(ne.$$.fragment),Ye=r(),m(re.$$.fragment),Ke=r(),ae=l("p"),ae.innerHTML=Ot,et=r(),m(se.$$.fragment),tt=r(),P=l("div"),m(ie.$$.fragment),ft=r(),Pe=l("p"),Pe.innerHTML=qt,ut=r(),$e=l("p"),$e.innerHTML=Et,gt=r(),m(q.$$.fragment),ot=r(),m(ce.$$.fragment),nt=r(),b=l("div"),m(le.$$.fragment),_t=r(),we=l("p"),we.textContent=Gt,xt=r(),Se=l("p"),Se.innerHTML=Vt,Tt=r(),Fe=l("p"),Fe.innerHTML=Xt,vt=r(),H=l("div"),m(de.$$.fragment),bt=r(),ye=l("p"),ye.innerHTML=At,Mt=r(),m(E.$$.fragment),rt=r(),m(me.$$.fragment),at=r(),C=l("div"),m(he.$$.fragment),Pt=r(),Ce=l("p"),Ce.innerHTML=Qt,$t=r(),I=l("div"),m(pe.$$.fragment),wt=r(),ke=l("p"),ke.innerHTML=Yt,St=r(),m(G.$$.fragment),st=r(),m(fe.$$.fragment),it=r(),k=l("div"),m(ue.$$.fragment),Ft=r(),Ne=l("p"),Ne.innerHTML=Kt,yt=r(),R=l("div"),m(ge.$$.fragment),Ct=r(),Je=l("p"),Je.innerHTML=eo,kt=r(),m(V.$$.fragment),ct=r(),m(_e.$$.fragment),lt=r(),N=l("div"),m(xe.$$.fragment),Nt=r(),Le=l("p"),Le.innerHTML=to,Jt=r(),U=l("div"),m(Te.$$.fragment),Lt=r(),ze=l("p"),ze.innerHTML=oo,zt=r(),m(X.$$.fragment),dt=r(),m(ve.$$.fragment),mt=r(),J=l("div"),m(be.$$.fragment),Ht=r(),He=l("p"),He.innerHTML=no,It=r(),W=l("div"),m(Me.$$.fragment),Rt=r(),Ie=l("p"),Ie.innerHTML=ro,Ut=r(),m(A.$$.fragment),ht=r(),je=l("p"),this.h()},l(e){const t=mo("svelte-u9bgzb",document.head);n=d(t,"META",{name:!0,content:!0}),t.forEach(o),x=a(e),c=d(e,"P",{}),w(c).forEach(o),T=a(e),h(F.$$.fragment,e),v=a(e),h(y.$$.fragment,e),qe=a(e),Q=d(e,"P",{"data-svelte-h":!0}),_(Q)!=="svelte-1f99jzv"&&(Q.innerHTML=Wt),Ee=a(e),Y=d(e,"P",{"data-svelte-h":!0}),_(Y)!=="svelte-11flhn7"&&(Y.textContent=Dt),Ge=a(e),K=d(e,"P",{"data-svelte-h":!0}),_(K)!=="svelte-vfdo9a"&&(K.textContent=Bt),Ve=a(e),ee=d(e,"P",{"data-svelte-h":!0}),_(ee)!=="svelte-ih5i3b"&&(ee.innerHTML=Zt),Xe=a(e),te=d(e,"P",{"data-svelte-h":!0}),_(te)!=="svelte-39frtq"&&(te.innerHTML=jt),Ae=a(e),h(oe.$$.fragment,e),Qe=a(e),h(ne.$$.fragment,e),Ye=a(e),h(re.$$.fragment,e),Ke=a(e),ae=d(e,"P",{"data-svelte-h":!0}),_(ae)!=="svelte-g6bt87"&&(ae.innerHTML=Ot),et=a(e),h(se.$$.fragment,e),tt=a(e),P=d(e,"DIV",{class:!0});var L=w(P);h(ie.$$.fragment,L),ft=a(L),Pe=d(L,"P",{"data-svelte-h":!0}),_(Pe)!=="svelte-jvslfp"&&(Pe.innerHTML=qt),ut=a(L),$e=d(L,"P",{"data-svelte-h":!0}),_($e)!=="svelte-o55m63"&&($e.innerHTML=Et),gt=a(L),h(q.$$.fragment,L),L.forEach(o),ot=a(e),h(ce.$$.fragment,e),nt=a(e),b=d(e,"DIV",{class:!0});var $=w(b);h(le.$$.fragment,$),_t=a($),we=d($,"P",{"data-svelte-h":!0}),_(we)!=="svelte-vx4bol"&&(we.textContent=Gt),xt=a($),Se=d($,"P",{"data-svelte-h":!0}),_(Se)!=="svelte-6pahdo"&&(Se.innerHTML=Vt),Tt=a($),Fe=d($,"P",{"data-svelte-h":!0}),_(Fe)!=="svelte-hswkmf"&&(Fe.innerHTML=Xt),vt=a($),H=d($,"DIV",{class:!0});var B=w(H);h(de.$$.fragment,B),bt=a(B),ye=d(B,"P",{"data-svelte-h":!0}),_(ye)!=="svelte-1w23flr"&&(ye.innerHTML=At),Mt=a(B),h(E.$$.fragment,B),B.forEach(o),$.forEach(o),rt=a(e),h(me.$$.fragment,e),at=a(e),C=d(e,"DIV",{class:!0});var Z=w(C);h(he.$$.fragment,Z),Pt=a(Z),Ce=d(Z,"P",{"data-svelte-h":!0}),_(Ce)!=="svelte-xt1t9t"&&(Ce.innerHTML=Qt),$t=a(Z),I=d(Z,"DIV",{class:!0});var j=w(I);h(pe.$$.fragment,j),wt=a(j),ke=d(j,"P",{"data-svelte-h":!0}),_(ke)!=="svelte-18ml2xj"&&(ke.innerHTML=Yt),St=a(j),h(G.$$.fragment,j),j.forEach(o),Z.forEach(o),st=a(e),h(fe.$$.fragment,e),it=a(e),k=d(e,"DIV",{class:!0});var O=w(k);h(ue.$$.fragment,O),Ft=a(O),Ne=d(O,"P",{"data-svelte-h":!0}),_(Ne)!=="svelte-dtnn1m"&&(Ne.innerHTML=Kt),yt=a(O),R=d(O,"DIV",{class:!0});var Re=w(R);h(ge.$$.fragment,Re),Ct=a(Re),Je=d(Re,"P",{"data-svelte-h":!0}),_(Je)!=="svelte-kaucen"&&(Je.innerHTML=eo),kt=a(Re),h(V.$$.fragment,Re),Re.forEach(o),O.forEach(o),ct=a(e),h(_e.$$.fragment,e),lt=a(e),N=d(e,"DIV",{class:!0});var Ue=w(N);h(xe.$$.fragment,Ue),Nt=a(Ue),Le=d(Ue,"P",{"data-svelte-h":!0}),_(Le)!=="svelte-9xefdl"&&(Le.innerHTML=to),Jt=a(Ue),U=d(Ue,"DIV",{class:!0});var We=w(U);h(Te.$$.fragment,We),Lt=a(We),ze=d(We,"P",{"data-svelte-h":!0}),_(ze)!=="svelte-i45907"&&(ze.innerHTML=oo),zt=a(We),h(X.$$.fragment,We),We.forEach(o),Ue.forEach(o),dt=a(e),h(ve.$$.fragment,e),mt=a(e),J=d(e,"DIV",{class:!0});var De=w(J);h(be.$$.fragment,De),Ht=a(De),He=d(De,"P",{"data-svelte-h":!0}),_(He)!=="svelte-1m09nil"&&(He.innerHTML=no),It=a(De),W=d(De,"DIV",{class:!0});var Be=w(W);h(Me.$$.fragment,Be),Rt=a(Be),Ie=d(Be,"P",{"data-svelte-h":!0}),_(Ie)!=="svelte-s3elmv"&&(Ie.innerHTML=ro),Ut=a(Be),h(A.$$.fragment,Be),Be.forEach(o),De.forEach(o),ht=a(e),je=d(e,"P",{}),w(je).forEach(o),this.h()},h(){S(n,"name","hf:doc:metadata"),S(n,"content",vo),S(P,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),S(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),S(b,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),S(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),S(C,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),S(R,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),S(k,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),S(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),S(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),S(W,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),S(J,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(e,t){i(document.head,n),s(e,x,t),s(e,c,t),s(e,T,t),p(F,e,t),s(e,v,t),p(y,e,t),s(e,qe,t),s(e,Q,t),s(e,Ee,t),s(e,Y,t),s(e,Ge,t),s(e,K,t),s(e,Ve,t),s(e,ee,t),s(e,Xe,t),s(e,te,t),s(e,Ae,t),p(oe,e,t),s(e,Qe,t),p(ne,e,t),s(e,Ye,t),p(re,e,t),s(e,Ke,t),s(e,ae,t),s(e,et,t),p(se,e,t),s(e,tt,t),s(e,P,t),p(ie,P,null),i(P,ft),i(P,Pe),i(P,ut),i(P,$e),i(P,gt),p(q,P,null),s(e,ot,t),p(ce,e,t),s(e,nt,t),s(e,b,t),p(le,b,null),i(b,_t),i(b,we),i(b,xt),i(b,Se),i(b,Tt),i(b,Fe),i(b,vt),i(b,H),p(de,H,null),i(H,bt),i(H,ye),i(H,Mt),p(E,H,null),s(e,rt,t),p(me,e,t),s(e,at,t),s(e,C,t),p(he,C,null),i(C,Pt),i(C,Ce),i(C,$t),i(C,I),p(pe,I,null),i(I,wt),i(I,ke),i(I,St),p(G,I,null),s(e,st,t),p(fe,e,t),s(e,it,t),s(e,k,t),p(ue,k,null),i(k,Ft),i(k,Ne),i(k,yt),i(k,R),p(ge,R,null),i(R,Ct),i(R,Je),i(R,kt),p(V,R,null),s(e,ct,t),p(_e,e,t),s(e,lt,t),s(e,N,t),p(xe,N,null),i(N,Nt),i(N,Le),i(N,Jt),i(N,U),p(Te,U,null),i(U,Lt),i(U,ze),i(U,zt),p(X,U,null),s(e,dt,t),p(ve,e,t),s(e,mt,t),s(e,J,t),p(be,J,null),i(J,Ht),i(J,He),i(J,It),i(J,W),p(Me,W,null),i(W,Rt),i(W,Ie),i(W,Ut),p(A,W,null),s(e,ht,t),s(e,je,t),pt=!0},p(e,[t]){const L={};t&2&&(L.$$scope={dirty:t,ctx:e}),q.$set(L);const $={};t&2&&($.$$scope={dirty:t,ctx:e}),E.$set($);const B={};t&2&&(B.$$scope={dirty:t,ctx:e}),G.$set(B);const Z={};t&2&&(Z.$$scope={dirty:t,ctx:e}),V.$set(Z);const j={};t&2&&(j.$$scope={dirty:t,ctx:e}),X.$set(j);const O={};t&2&&(O.$$scope={dirty:t,ctx:e}),A.$set(O)},i(e){pt||(f(F.$$.fragment,e),f(y.$$.fragment,e),f(oe.$$.fragment,e),f(ne.$$.fragment,e),f(re.$$.fragment,e),f(se.$$.fragment,e),f(ie.$$.fragment,e),f(q.$$.fragment,e),f(ce.$$.fragment,e),f(le.$$.fragment,e),f(de.$$.fragment,e),f(E.$$.fragment,e),f(me.$$.fragment,e),f(he.$$.fragment,e),f(pe.$$.fragment,e),f(G.$$.fragment,e),f(fe.$$.fragment,e),f(ue.$$.fragment,e),f(ge.$$.fragment,e),f(V.$$.fragment,e),f(_e.$$.fragment,e),f(xe.$$.fragment,e),f(Te.$$.fragment,e),f(X.$$.fragment,e),f(ve.$$.fragment,e),f(be.$$.fragment,e),f(Me.$$.fragment,e),f(A.$$.fragment,e),pt=!0)},o(e){u(F.$$.fragment,e),u(y.$$.fragment,e),u(oe.$$.fragment,e),u(ne.$$.fragment,e),u(re.$$.fragment,e),u(se.$$.fragment,e),u(ie.$$.fragment,e),u(q.$$.fragment,e),u(ce.$$.fragment,e),u(le.$$.fragment,e),u(de.$$.fragment,e),u(E.$$.fragment,e),u(me.$$.fragment,e),u(he.$$.fragment,e),u(pe.$$.fragment,e),u(G.$$.fragment,e),u(fe.$$.fragment,e),u(ue.$$.fragment,e),u(ge.$$.fragment,e),u(V.$$.fragment,e),u(_e.$$.fragment,e),u(xe.$$.fragment,e),u(Te.$$.fragment,e),u(X.$$.fragment,e),u(ve.$$.fragment,e),u(be.$$.fragment,e),u(Me.$$.fragment,e),u(A.$$.fragment,e),pt=!1},d(e){e&&(o(x),o(c),o(T),o(v),o(qe),o(Q),o(Ee),o(Y),o(Ge),o(K),o(Ve),o(ee),o(Xe),o(te),o(Ae),o(Qe),o(Ye),o(Ke),o(ae),o(et),o(tt),o(P),o(ot),o(nt),o(b),o(rt),o(at),o(C),o(st),o(it),o(k),o(ct),o(lt),o(N),o(dt),o(mt),o(J),o(ht),o(je)),o(n),g(F,e),g(y,e),g(oe,e),g(ne,e),g(re,e),g(se,e),g(ie),g(q),g(ce,e),g(le),g(de),g(E),g(me,e),g(he),g(pe),g(G),g(fe,e),g(ue),g(ge),g(V),g(_e,e),g(xe),g(Te),g(X),g(ve,e),g(be),g(Me),g(A)}}}const vo='{"title":"PatchTSMixer","local":"patchtsmixer","sections":[{"title":"Overview","local":"overview","sections":[],"depth":2},{"title":"Sample usage","local":"sample-usage","sections":[],"depth":2},{"title":"Usage tips","local":"usage-tips","sections":[],"depth":2},{"title":"PatchTSMixerConfig","local":"transformers.PatchTSMixerConfig","sections":[],"depth":2},{"title":"PatchTSMixerModel","local":"transformers.PatchTSMixerModel","sections":[],"depth":2},{"title":"PatchTSMixerForPrediction","local":"transformers.PatchTSMixerForPrediction","sections":[],"depth":2},{"title":"PatchTSMixerForTimeSeriesClassification","local":"transformers.PatchTSMixerForTimeSeriesClassification","sections":[],"depth":2},{"title":"PatchTSMixerForPretraining","local":"transformers.PatchTSMixerForPretraining","sections":[],"depth":2},{"title":"PatchTSMixerForRegression","local":"transformers.PatchTSMixerForRegression","sections":[],"depth":2}],"depth":1}';function bo(M){return io(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Co extends co{constructor(n){super(),lo(this,n,bo,To,so,{})}}export{Co as component};
