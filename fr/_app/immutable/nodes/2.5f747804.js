import{s as qe,o as Ve,n as ve}from"../chunks/scheduler.987d3921.js";import{S as He,i as Re,g as f,s as i,r as j,A as Ae,h,f as t,c,j as Ue,u as y,x,k as ze,y as Ee,a,v,d as M,t as w,w as C}from"../chunks/index.c8b1fed4.js";import{T as Fe,C as F}from"../chunks/CodeBlock.a6b7bf84.js";import{F as Le,M as Ge}from"../chunks/Markdown.506a0c7c.js";import{H as O}from"../chunks/Heading.3fa3b67f.js";function Xe(J){let n,m='Rappel, l‚Äôarchitecture fait r√©f√©rence au squelette du mod√®le et l‚Äôensemble de poids contient les poids pour une architecture donn√©e. Par exemple, <a href="https://huggingface.co/google-bert/bert-base-uncased" rel="nofollow">BERT</a> est une architecture, tandis que <code>google-bert/bert-base-uncased</code> est un ensemble de poids. Le terme mod√®le est g√©n√©ral et peut signifier soit architecture soit ensemble de poids.';return{c(){n=f("p"),n.innerHTML=m},l(l){n=h(l,"P",{"data-svelte-h":!0}),x(n)!=="svelte-1wpwywa"&&(n.innerHTML=m)},m(l,o){a(l,n,o)},p:ve,d(l){l&&t(n)}}}function Pe(J){let n,m='Pour les mod√®les PyTorch, la fonction <code>from_pretrained()</code> utilise <code>torch.load()</code> qui utilise <code>pickle</code> en interne et est connu pour √™tre non s√©curis√©. En g√©n√©ral, ne chargez jamais un mod√®le qui pourrait provenir d‚Äôune source non fiable, ou qui pourrait avoir √©t√© alt√©r√©. Ce risque de s√©curit√© est partiellement att√©nu√© pour les mod√®les h√©berg√©s publiquement sur le Hugging Face Hub, qui sont <a href="https://huggingface.co/docs/hub/security-malware" rel="nofollow">scann√©s pour les logiciels malveillants</a> √† chaque modification. Consultez la <a href="https://huggingface.co/docs/hub/security" rel="nofollow">documentation du Hub</a> pour conna√Ætre les meilleures pratiques comme la <a href="https://huggingface.co/docs/hub/security-gpg#signing-commits-with-gpg" rel="nofollow">v√©rification des modifications sign√©es</a> avec GPG.',l,o,d="Les points de contr√¥le TensorFlow et Flax ne sont pas concern√©s, et peuvent √™tre charg√©s dans des architectures PyTorch en utilisant les arguments <code>from_tf</code> et <code>from_flax</code> de la fonction <code>from_pretrained</code> pour contourner ce probl√®me.";return{c(){n=f("p"),n.innerHTML=m,l=i(),o=f("p"),o.innerHTML=d},l(u){n=h(u,"P",{"data-svelte-h":!0}),x(n)!=="svelte-l4u8jp"&&(n.innerHTML=m),l=c(u),o=h(u,"P",{"data-svelte-h":!0}),x(o)!=="svelte-1u5j2m"&&(o.innerHTML=d)},m(u,k){a(u,n,k),a(u,l,k),a(u,o,k)},p:ve,d(u){u&&(t(n),t(l),t(o))}}}function Ne(J){let n,m='Enfin, les classes <code>AutoModelFor</code> vous permettent de charger un mod√®le pr√©-entra√Æn√© pour une t√¢che donn√©e (voir <a href="model_doc/auto">ici</a> pour une liste compl√®te des t√¢ches disponibles). Par exemple, chargez un mod√®le pour la classification de s√©quence avec <code>AutoModelForSequenceClassification.from_pretrained()</code>:',l,o,d,u,k="R√©utilisez facilement le m√™me ensemble de poids pour charger une architecture pour une t√¢che diff√©rente :",U,b,T,$,_,W,p='En g√©n√©ral, nous recommandons d‚Äôutiliser les classes <code>AutoTokenizer</code> et <code>AutoModelFor</code> pour charger des instances pr√©-entra√Æn√©es de tokenizers et mod√®les respectivement. Cela vous permettra de charger la bonne architecture √† chaque fois. Dans le prochain <a href="preprocessing">tutoriel</a>, vous apprenez √† utiliser un tokenizer, processeur d‚Äôimage, extracteur de caract√©ristiques et processeur pour pr√©-traiter un jeu de donn√©es pour le fine-tuning.',g;return o=new F({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Nb2RlbEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24lMEElMEFtb2RlbCUyMCUzRCUyMEF1dG9Nb2RlbEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24uZnJvbV9wcmV0cmFpbmVkKCUyMmRpc3RpbGJlcnQlMkZkaXN0aWxiZXJ0LWJhc2UtdW5jYXNlZCUyMik=",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model = AutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert/distilbert-base-uncased&quot;</span>)`,wrap:!1}}),b=new F({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Nb2RlbEZvclRva2VuQ2xhc3NpZmljYXRpb24lMEElMEFtb2RlbCUyMCUzRCUyMEF1dG9Nb2RlbEZvclRva2VuQ2xhc3NpZmljYXRpb24uZnJvbV9wcmV0cmFpbmVkKCUyMmRpc3RpbGJlcnQlMkZkaXN0aWxiZXJ0LWJhc2UtdW5jYXNlZCUyMik=",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForTokenClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model = AutoModelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;distilbert/distilbert-base-uncased&quot;</span>)`,wrap:!1}}),$=new Fe({props:{warning:!0,$$slots:{default:[Pe]},$$scope:{ctx:J}}}),{c(){n=f("p"),n.innerHTML=m,l=i(),j(o.$$.fragment),d=i(),u=f("p"),u.textContent=k,U=i(),j(b.$$.fragment),T=i(),j($.$$.fragment),_=i(),W=f("p"),W.innerHTML=p},l(r){n=h(r,"P",{"data-svelte-h":!0}),x(n)!=="svelte-18hdm39"&&(n.innerHTML=m),l=c(r),y(o.$$.fragment,r),d=c(r),u=h(r,"P",{"data-svelte-h":!0}),x(u)!=="svelte-4q5xnw"&&(u.textContent=k),U=c(r),y(b.$$.fragment,r),T=c(r),y($.$$.fragment,r),_=c(r),W=h(r,"P",{"data-svelte-h":!0}),x(W)!=="svelte-1i30k28"&&(W.innerHTML=p)},m(r,Z){a(r,n,Z),a(r,l,Z),v(o,r,Z),a(r,d,Z),a(r,u,Z),a(r,U,Z),v(b,r,Z),a(r,T,Z),v($,r,Z),a(r,_,Z),a(r,W,Z),g=!0},p(r,Z){const z={};Z&2&&(z.$$scope={dirty:Z,ctx:r}),$.$set(z)},i(r){g||(M(o.$$.fragment,r),M(b.$$.fragment,r),M($.$$.fragment,r),g=!0)},o(r){w(o.$$.fragment,r),w(b.$$.fragment,r),w($.$$.fragment,r),g=!1},d(r){r&&(t(n),t(l),t(d),t(u),t(U),t(T),t(_),t(W)),C(o,r),C(b,r),C($,r)}}}function Ye(J){let n,m;return n=new Ge({props:{$$slots:{default:[Ne]},$$scope:{ctx:J}}}),{c(){j(n.$$.fragment)},l(l){y(n.$$.fragment,l)},m(l,o){v(n,l,o),m=!0},p(l,o){const d={};o&2&&(d.$$scope={dirty:o,ctx:l}),n.$set(d)},i(l){m||(M(n.$$.fragment,l),m=!0)},o(l){w(n.$$.fragment,l),m=!1},d(l){C(n,l)}}}function Ie(J){let n,m='Enfin, les classes <code>TFAutoModelFor</code> vous permettent de charger un mod√®le pr√©-entra√Æn√© pour une t√¢che donn√©e (voir <a href="model_doc/auto">ici</a> pour une liste compl√®te des t√¢ches disponibles). Par exemple, chargez un mod√®le pour la classification de s√©quence avec <code>TFAutoModelForSequenceClassification.from_pretrained()</code>:',l,o,d,u,k="R√©utilisez facilement le m√™me ensemble de poids pour charger une architecture pour une t√¢che diff√©rente :",U,b,T,$,_='En g√©n√©ral, nous recommandons d‚Äôutiliser les classes <code>AutoTokenizer</code> et <code>TFAutoModelFor</code> pour charger des instances pr√©-entra√Æn√©es de tokenizers et mod√®les respectivement. Cela vous permettra de charger la bonne architecture √† chaque fois. Dans le prochain <a href="preprocessing">tutoriel</a>, vous apprenez √† utiliser un tokenizer, processeur d‚Äôimage, extracteur de caract√©ristiques et processeur pour pr√©-traiter un jeu de donn√©es pour le fine-tuning.',W;return o=new F({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFRGQXV0b01vZGVsRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbiUwQSUwQW1vZGVsJTIwJTNEJTIwVEZBdXRvTW9kZWxGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uLmZyb21fcHJldHJhaW5lZCglMjJkaXN0aWxiZXJ0JTJGZGlzdGlsYmVydC1iYXNlLXVuY2FzZWQlMjIp",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFAutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert/distilbert-base-uncased&quot;</span>)`,wrap:!1}}),b=new F({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFRGQXV0b01vZGVsRm9yVG9rZW5DbGFzc2lmaWNhdGlvbiUwQSUwQW1vZGVsJTIwJTNEJTIwVEZBdXRvTW9kZWxGb3JUb2tlbkNsYXNzaWZpY2F0aW9uLmZyb21fcHJldHJhaW5lZCglMjJkaXN0aWxiZXJ0JTJGZGlzdGlsYmVydC1iYXNlLXVuY2FzZWQlMjIp",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModelForTokenClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFAutoModelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;distilbert/distilbert-base-uncased&quot;</span>)`,wrap:!1}}),{c(){n=f("p"),n.innerHTML=m,l=i(),j(o.$$.fragment),d=i(),u=f("p"),u.textContent=k,U=i(),j(b.$$.fragment),T=i(),$=f("p"),$.innerHTML=_},l(p){n=h(p,"P",{"data-svelte-h":!0}),x(n)!=="svelte-13f9mbl"&&(n.innerHTML=m),l=c(p),y(o.$$.fragment,p),d=c(p),u=h(p,"P",{"data-svelte-h":!0}),x(u)!=="svelte-4q5xnw"&&(u.textContent=k),U=c(p),y(b.$$.fragment,p),T=c(p),$=h(p,"P",{"data-svelte-h":!0}),x($)!=="svelte-pfm38e"&&($.innerHTML=_)},m(p,g){a(p,n,g),a(p,l,g),v(o,p,g),a(p,d,g),a(p,u,g),a(p,U,g),v(b,p,g),a(p,T,g),a(p,$,g),W=!0},p:ve,i(p){W||(M(o.$$.fragment,p),M(b.$$.fragment,p),W=!0)},o(p){w(o.$$.fragment,p),w(b.$$.fragment,p),W=!1},d(p){p&&(t(n),t(l),t(d),t(u),t(U),t(T),t($)),C(o,p),C(b,p)}}}function Qe(J){let n,m;return n=new Ge({props:{$$slots:{default:[Ie]},$$scope:{ctx:J}}}),{c(){j(n.$$.fragment)},l(l){y(n.$$.fragment,l)},m(l,o){v(n,l,o),m=!0},p(l,o){const d={};o&2&&(d.$$scope={dirty:o,ctx:l}),n.$set(d)},i(l){m||(M(n.$$.fragment,l),m=!0)},o(l){w(n.$$.fragment,l),m=!1},d(l){C(n,l)}}}function Be(J){let n,m,l,o,d,u,k,U="Avec autant d‚Äôarchitectures Transformer diff√©rentes, il peut √™tre difficile d‚Äôen cr√©er une pour votre ensemble de poids (aussi appel√©s ‚Äúweights‚Äù ou ‚Äúcheckpoint‚Äù en anglais). Dans l‚Äôid√©e de cr√©er une librairie facile, simple et flexible √† utiliser, ü§ó Transformers fournit une <code>AutoClass</code> qui inf√®re et charge automatiquement l‚Äôarchitecture correcte √† partir d‚Äôun ensemble de poids donn√©. La fonction <code>from_pretrained()</code> vous permet de charger rapidement un mod√®le pr√©-entra√Æn√© pour n‚Äôimporte quelle architecture afin que vous n‚Äôayez pas √† consacrer du temps et des ressources √† l‚Äôentra√Ænement d‚Äôun mod√®le √† partir de z√©ro. Produire un tel code ind√©pendant d‚Äôun ensemble de poids signifie que si votre code fonctionne pour un ensemble de poids, il fonctionnera avec un autre ensemble - tant qu‚Äôil a √©t√© entra√Æn√© pour une t√¢che similaire - m√™me si l‚Äôarchitecture est diff√©rente.",b,T,$,_,W="Dans ce tutoriel, vous apprendrez √†:",p,g,r="<li>Charger un tokenizer pr√©-entra√Æn√©.</li> <li>Charger un processeur d‚Äôimage pr√©-entra√Æn√©.</li> <li>Charger un extracteur de caract√©ristiques pr√©-entra√Æn√©.</li> <li>Charger un processeur pr√©-entra√Æn√©.</li> <li>Charger un mod√®le pr√©-entra√Æn√©.</li>",Z,z,te,q,Me="Quasiment toutes les t√¢ches de traitement du langage (NLP) commencent avec un tokenizer. Un tokenizer convertit votre texte initial dans un format qui peut √™tre trait√© par le mod√®le.",se,V,we="Chargez un tokenizer avec <code>AutoTokenizer.from_pretrained()</code>:",ne,H,ae,R,Ce="Puis, transformez votre texte initial comme montr√© ci-dessous:",le,A,re,E,oe,L,xe="Pour les t√¢ches de vision, un processeur d‚Äôimage traite l‚Äôimage pour la formater correctment.",pe,X,ie,P,ce,N,Ze="Pour les t√¢ches audio, un extracteur de caract√©ristiques (aussi appel√©s ‚Äúfeatures‚Äù en anglais) traite le signal audio pour le formater correctement.",ue,Y,Te="Chargez un extracteur de caract√©ristiques avec <code>AutoFeatureExtractor.from_pretrained()</code>:",me,I,de,Q,fe,B,ke='Les t√¢ches multimodales n√©cessitent un processeur qui combine deux types d‚Äôoutils de pr√©traitement. Par exemple, le mod√®le <a href="model_doc/layoutlmv2">LayoutLMV2</a> n√©cessite un processeur d‚Äôimage pour traiter les images et un tokenizer pour traiter le texte ; un processeur combine les deux.',he,S,_e="Chargez un processeur avec <code>AutoProcessor.from_pretrained()</code>:",ge,D,$e,K,be,G,je,ee,ye;return d=new O({props:{title:"Chargement d‚Äôinstances pr√©-entra√Æn√©es avec une AutoClass",local:"chargement-dinstances-pr√©-entra√Æn√©es-avec-une-autoclass",headingTag:"h1"}}),T=new Fe({props:{$$slots:{default:[Xe]},$$scope:{ctx:J}}}),z=new O({props:{title:"AutoTokenizer",local:"autotokenizer",headingTag:"h2"}}),H=new F({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Ub2tlbml6ZXIlMEElMEF0b2tlbml6ZXIlMjAlM0QlMjBBdXRvVG9rZW5pemVyLmZyb21fcHJldHJhaW5lZCglMjJnb29nbGUtYmVydCUyRmJlcnQtYmFzZS11bmNhc2VkJTIyKQ==",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;google-bert/bert-base-uncased&quot;</span>)`,wrap:!1}}),A=new F({props:{code:"c2VxdWVuY2UlMjAlM0QlMjAlMjJJbiUyMGElMjBob2xlJTIwaW4lMjB0aGUlMjBncm91bmQlMjB0aGVyZSUyMGxpdmVkJTIwYSUyMGhvYmJpdC4lMjIlMEFwcmludCh0b2tlbml6ZXIoc2VxdWVuY2UpKQ==",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>sequence = <span class="hljs-string">&quot;In a hole in the ground there lived a hobbit.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(tokenizer(sequence))
{<span class="hljs-string">&#x27;input_ids&#x27;</span>: [<span class="hljs-number">101</span>, <span class="hljs-number">1999</span>, <span class="hljs-number">1037</span>, <span class="hljs-number">4920</span>, <span class="hljs-number">1999</span>, <span class="hljs-number">1996</span>, <span class="hljs-number">2598</span>, <span class="hljs-number">2045</span>, <span class="hljs-number">2973</span>, <span class="hljs-number">1037</span>, <span class="hljs-number">7570</span>, <span class="hljs-number">10322</span>, <span class="hljs-number">4183</span>, <span class="hljs-number">1012</span>, <span class="hljs-number">102</span>], 
 <span class="hljs-string">&#x27;token_type_ids&#x27;</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], 
 <span class="hljs-string">&#x27;attention_mask&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]}`,wrap:!1}}),E=new O({props:{title:"AutoImageProcessor",local:"autoimageprocessor",headingTag:"h2"}}),X=new F({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9JbWFnZVByb2Nlc3NvciUwQSUwQWltYWdlX3Byb2Nlc3NvciUyMCUzRCUyMEF1dG9JbWFnZVByb2Nlc3Nvci5mcm9tX3ByZXRyYWluZWQoJTIyZ29vZ2xlJTJGdml0LWJhc2UtcGF0Y2gxNi0yMjQlMjIp",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoImageProcessor

<span class="hljs-meta">&gt;&gt;&gt; </span>image_processor = AutoImageProcessor.from_pretrained(<span class="hljs-string">&quot;google/vit-base-patch16-224&quot;</span>)`,wrap:!1}}),P=new O({props:{title:"AutoFeatureExtractor",local:"autofeatureextractor",headingTag:"h2"}}),I=new F({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9GZWF0dXJlRXh0cmFjdG9yJTBBJTBBZmVhdHVyZV9leHRyYWN0b3IlMjAlM0QlMjBBdXRvRmVhdHVyZUV4dHJhY3Rvci5mcm9tX3ByZXRyYWluZWQoJTBBJTIwJTIwJTIwJTIwJTIyZWhjYWxhYnJlcyUyRndhdjJ2ZWMyLWxnLXhsc3ItZW4tc3BlZWNoLWVtb3Rpb24tcmVjb2duaXRpb24lMjIlMEEp",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoFeatureExtractor

<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = AutoFeatureExtractor.from_pretrained(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;ehcalabres/wav2vec2-lg-xlsr-en-speech-emotion-recognition&quot;</span>
<span class="hljs-meta">... </span>)`,wrap:!1}}),Q=new O({props:{title:"AutoProcessor",local:"autoprocessor",headingTag:"h2"}}),D=new F({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Qcm9jZXNzb3IlMEElMEFwcm9jZXNzb3IlMjAlM0QlMjBBdXRvUHJvY2Vzc29yLmZyb21fcHJldHJhaW5lZCglMjJtaWNyb3NvZnQlMkZsYXlvdXRsbXYyLWJhc2UtdW5jYXNlZCUyMik=",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoProcessor

<span class="hljs-meta">&gt;&gt;&gt; </span>processor = AutoProcessor.from_pretrained(<span class="hljs-string">&quot;microsoft/layoutlmv2-base-uncased&quot;</span>)`,wrap:!1}}),K=new O({props:{title:"AutoModel",local:"automodel",headingTag:"h2"}}),G=new Le({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[Qe],pytorch:[Ye]},$$scope:{ctx:J}}}),{c(){n=f("meta"),m=i(),l=f("p"),o=i(),j(d.$$.fragment),u=i(),k=f("p"),k.innerHTML=U,b=i(),j(T.$$.fragment),$=i(),_=f("p"),_.textContent=W,p=i(),g=f("ul"),g.innerHTML=r,Z=i(),j(z.$$.fragment),te=i(),q=f("p"),q.textContent=Me,se=i(),V=f("p"),V.innerHTML=we,ne=i(),j(H.$$.fragment),ae=i(),R=f("p"),R.textContent=Ce,le=i(),j(A.$$.fragment),re=i(),j(E.$$.fragment),oe=i(),L=f("p"),L.textContent=xe,pe=i(),j(X.$$.fragment),ie=i(),j(P.$$.fragment),ce=i(),N=f("p"),N.textContent=Ze,ue=i(),Y=f("p"),Y.innerHTML=Te,me=i(),j(I.$$.fragment),de=i(),j(Q.$$.fragment),fe=i(),B=f("p"),B.innerHTML=ke,he=i(),S=f("p"),S.innerHTML=_e,ge=i(),j(D.$$.fragment),$e=i(),j(K.$$.fragment),be=i(),j(G.$$.fragment),je=i(),ee=f("p"),this.h()},l(e){const s=Ae("svelte-u9bgzb",document.head);n=h(s,"META",{name:!0,content:!0}),s.forEach(t),m=c(e),l=h(e,"P",{}),Ue(l).forEach(t),o=c(e),y(d.$$.fragment,e),u=c(e),k=h(e,"P",{"data-svelte-h":!0}),x(k)!=="svelte-14j8kat"&&(k.innerHTML=U),b=c(e),y(T.$$.fragment,e),$=c(e),_=h(e,"P",{"data-svelte-h":!0}),x(_)!=="svelte-11wzqi4"&&(_.textContent=W),p=c(e),g=h(e,"UL",{"data-svelte-h":!0}),x(g)!=="svelte-1zsy1p"&&(g.innerHTML=r),Z=c(e),y(z.$$.fragment,e),te=c(e),q=h(e,"P",{"data-svelte-h":!0}),x(q)!=="svelte-11nrus5"&&(q.textContent=Me),se=c(e),V=h(e,"P",{"data-svelte-h":!0}),x(V)!=="svelte-193g694"&&(V.innerHTML=we),ne=c(e),y(H.$$.fragment,e),ae=c(e),R=h(e,"P",{"data-svelte-h":!0}),x(R)!=="svelte-ao3i5v"&&(R.textContent=Ce),le=c(e),y(A.$$.fragment,e),re=c(e),y(E.$$.fragment,e),oe=c(e),L=h(e,"P",{"data-svelte-h":!0}),x(L)!=="svelte-684eca"&&(L.textContent=xe),pe=c(e),y(X.$$.fragment,e),ie=c(e),y(P.$$.fragment,e),ce=c(e),N=h(e,"P",{"data-svelte-h":!0}),x(N)!=="svelte-1oa24x4"&&(N.textContent=Ze),ue=c(e),Y=h(e,"P",{"data-svelte-h":!0}),x(Y)!=="svelte-zzw1z0"&&(Y.innerHTML=Te),me=c(e),y(I.$$.fragment,e),de=c(e),y(Q.$$.fragment,e),fe=c(e),B=h(e,"P",{"data-svelte-h":!0}),x(B)!=="svelte-jvjc4f"&&(B.innerHTML=ke),he=c(e),S=h(e,"P",{"data-svelte-h":!0}),x(S)!=="svelte-mncaiv"&&(S.innerHTML=_e),ge=c(e),y(D.$$.fragment,e),$e=c(e),y(K.$$.fragment,e),be=c(e),y(G.$$.fragment,e),je=c(e),ee=h(e,"P",{}),Ue(ee).forEach(t),this.h()},h(){ze(n,"name","hf:doc:metadata"),ze(n,"content",Se)},m(e,s){Ee(document.head,n),a(e,m,s),a(e,l,s),a(e,o,s),v(d,e,s),a(e,u,s),a(e,k,s),a(e,b,s),v(T,e,s),a(e,$,s),a(e,_,s),a(e,p,s),a(e,g,s),a(e,Z,s),v(z,e,s),a(e,te,s),a(e,q,s),a(e,se,s),a(e,V,s),a(e,ne,s),v(H,e,s),a(e,ae,s),a(e,R,s),a(e,le,s),v(A,e,s),a(e,re,s),v(E,e,s),a(e,oe,s),a(e,L,s),a(e,pe,s),v(X,e,s),a(e,ie,s),v(P,e,s),a(e,ce,s),a(e,N,s),a(e,ue,s),a(e,Y,s),a(e,me,s),v(I,e,s),a(e,de,s),v(Q,e,s),a(e,fe,s),a(e,B,s),a(e,he,s),a(e,S,s),a(e,ge,s),v(D,e,s),a(e,$e,s),v(K,e,s),a(e,be,s),v(G,e,s),a(e,je,s),a(e,ee,s),ye=!0},p(e,[s]){const We={};s&2&&(We.$$scope={dirty:s,ctx:e}),T.$set(We);const Je={};s&2&&(Je.$$scope={dirty:s,ctx:e}),G.$set(Je)},i(e){ye||(M(d.$$.fragment,e),M(T.$$.fragment,e),M(z.$$.fragment,e),M(H.$$.fragment,e),M(A.$$.fragment,e),M(E.$$.fragment,e),M(X.$$.fragment,e),M(P.$$.fragment,e),M(I.$$.fragment,e),M(Q.$$.fragment,e),M(D.$$.fragment,e),M(K.$$.fragment,e),M(G.$$.fragment,e),ye=!0)},o(e){w(d.$$.fragment,e),w(T.$$.fragment,e),w(z.$$.fragment,e),w(H.$$.fragment,e),w(A.$$.fragment,e),w(E.$$.fragment,e),w(X.$$.fragment,e),w(P.$$.fragment,e),w(I.$$.fragment,e),w(Q.$$.fragment,e),w(D.$$.fragment,e),w(K.$$.fragment,e),w(G.$$.fragment,e),ye=!1},d(e){e&&(t(m),t(l),t(o),t(u),t(k),t(b),t($),t(_),t(p),t(g),t(Z),t(te),t(q),t(se),t(V),t(ne),t(ae),t(R),t(le),t(re),t(oe),t(L),t(pe),t(ie),t(ce),t(N),t(ue),t(Y),t(me),t(de),t(fe),t(B),t(he),t(S),t(ge),t($e),t(be),t(je),t(ee)),t(n),C(d,e),C(T,e),C(z,e),C(H,e),C(A,e),C(E,e),C(X,e),C(P,e),C(I,e),C(Q,e),C(D,e),C(K,e),C(G,e)}}}const Se='{"title":"Chargement d‚Äôinstances pr√©-entra√Æn√©es avec une AutoClass","local":"chargement-dinstances-pr√©-entra√Æn√©es-avec-une-autoclass","sections":[{"title":"AutoTokenizer","local":"autotokenizer","sections":[],"depth":2},{"title":"AutoImageProcessor","local":"autoimageprocessor","sections":[],"depth":2},{"title":"AutoFeatureExtractor","local":"autofeatureextractor","sections":[],"depth":2},{"title":"AutoProcessor","local":"autoprocessor","sections":[],"depth":2},{"title":"AutoModel","local":"automodel","sections":[],"depth":2}],"depth":1}';function De(J){return Ve(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class nt extends He{constructor(n){super(),Re(this,n,De,Be,qe,{})}}export{nt as component};
