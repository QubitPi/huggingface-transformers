import{s as _t,n as $t,o as Pt}from"../chunks/scheduler.56730f09.js";import{S as xt,i as Ct,g as r,s as i,r as X,A as gt,h as p,f as l,c as a,j as dt,u as I,x as s,k as ht,y as bt,a as n,v as y,d as E,t as U,w as H}from"../chunks/index.1f144517.js";import{C as vt}from"../chunks/CodeBlock.738eeccb.js";import{H as k}from"../chunks/Heading.57d46534.js";function Tt(lt){let o,B,L,F,m,V,f,nt="이 가이드는 CPU에서 대규모 모델을 효율적으로 훈련하는 데 초점을 맞춥니다.",q,u,z,c,it="IPEX는 AVX-512 이상을 지원하는 CPU에 최적화되어 있으며, AVX2만 지원하는 CPU에도 기능적으로 작동합니다. 따라서 AVX-512 이상의 Intel CPU 세대에서는 성능상 이점이 있을 것으로 예상되지만, AVX2만 지원하는 CPU (예: AMD CPU 또는 오래된 Intel CPU)의 경우에는 IPEX 아래에서 더 나은 성능을 보일 수 있지만 이는 보장되지 않습니다. IPEX는 Float32와 BFloat16를 모두 사용하여 CPU 훈련을 위한 성능 최적화를 제공합니다. BFloat16의 사용은 다음 섹션의 주요 초점입니다.",G,d,at="저정밀도 데이터 타입인 BFloat16은 3세대 Xeon® Scalable 프로세서 (코드명: Cooper Lake)에서 AVX512 명령어 집합을 네이티브로 지원해 왔으며, 다음 세대의 Intel® Xeon® Scalable 프로세서에서 Intel® Advanced Matrix Extensions (Intel® AMX) 명령어 집합을 지원하여 성능을 크게 향상시킬 예정입니다. CPU 백엔드의 자동 혼합 정밀도 기능은 PyTorch-1.10부터 활성화되었습니다. 동시에, Intel® Extension for PyTorch에서 BFloat16에 대한 CPU의 자동 혼합 정밀도 및 연산자의 BFloat16 최적화를 대규모로 활성화하고, PyTorch 마스터 브랜치로 부분적으로 업스트림을 반영했습니다. 사용자들은 IPEX 자동 혼합 정밀도를 사용하여 더 나은 성능과 사용자 경험을 얻을 수 있습니다.",S,h,rt='<a href="https://intel.github.io/intel-extension-for-pytorch/cpu/latest/tutorials/features/amp.html" rel="nofollow">자동 혼합 정밀도</a>에 대한 자세한 정보를 확인하십시오.',R,_,Z,$,pt="IPEX 릴리스는 PyTorch를 따라갑니다. pip를 통해 설치하려면:",J,P,st='<thead><tr><th align="center">PyTorch Version</th> <th align="center">IPEX version</th></tr></thead> <tbody><tr><td align="center">1.13</td> <td align="center">1.13.0+cpu</td></tr> <tr><td align="center">1.12</td> <td align="center">1.12.300+cpu</td></tr> <tr><td align="center">1.11</td> <td align="center">1.11.200+cpu</td></tr> <tr><td align="center">1.10</td> <td align="center">1.10.100+cpu</td></tr></tbody>',j,x,W,C,ot='<a href="https://intel.github.io/intel-extension-for-pytorch/cpu/latest/tutorials/installation.html" rel="nofollow">IPEX 설치</a>에 대한 더 많은 접근 방법을 확인하십시오.',Y,g,N,b,mt="Trainer에서 IPEX의 자동 혼합 정밀도를 활성화하려면 사용자는 훈련 명령 인수에 <code>use_ipex</code>, <code>bf16</code>, <code>no_cuda</code>를 추가해야 합니다.",Q,v,ft='<a href="https://github.com/huggingface/transformers/tree/main/examples/pytorch/question-answering" rel="nofollow">Transformers 질문-응답</a>의 사용 사례를 살펴보겠습니다.',D,T,ut=`<li>CPU에서 BF16 자동 혼합 정밀도를 사용하여 IPEX로 훈련하기:<pre> python run_qa.py \\
--model_name_or_path google-bert/bert-base-uncased \\
--dataset_name squad \\
--do_train \\
--do_eval \\
--per_device_train_batch_size 12 \\
--learning_rate 3e-5 \\
--num_train_epochs 2 \\
--max_seq_length 384 \\
--doc_stride 128 \\
--output_dir /tmp/debug_squad/ \\
<b>--use_ipex \\</b>
<b>--bf16 --no_cuda</b></pre></li>`,K,w,O,M,ct='블로그: <a href="https://huggingface.co/blog/intel-sapphire-rapids" rel="nofollow">Intel Sapphire Rapids로 PyTorch Transformers 가속화</a>',tt,A,et;return m=new k({props:{title:"CPU에서 효율적인 훈련",local:"efficient-training-on-cpu",headingTag:"h1"}}),u=new k({props:{title:"IPEX와 혼합 정밀도",local:"mixed-precision-with-ipex",headingTag:"h2"}}),_=new k({props:{title:"IPEX 설치:",local:"ipex-installation",headingTag:"h3"}}),x=new vt({props:{code:"cGlwJTIwaW5zdGFsbCUyMGludGVsX2V4dGVuc2lvbl9mb3JfcHl0b3JjaCUzRCUzRCUzQ3ZlcnNpb25fbmFtZSUzRSUyMC1mJTIwaHR0cHMlM0ElMkYlMkZkZXZlbG9wZXIuaW50ZWwuY29tJTJGaXBleC13aGwtc3RhYmxlLWNwdQ==",highlighted:"pip install intel_extension_for_pytorch==&lt;version_name&gt; -f https://developer.intel.com/ipex-whl-stable-cpu",wrap:!1}}),g=new k({props:{title:"Trainer에서의 사용법",local:"usage-in-trainer",headingTag:"h3"}}),w=new k({props:{title:"실습 예시",local:"practice-example",headingTag:"h3"}}),{c(){o=r("meta"),B=i(),L=r("p"),F=i(),X(m.$$.fragment),V=i(),f=r("p"),f.textContent=nt,q=i(),X(u.$$.fragment),z=i(),c=r("p"),c.textContent=it,G=i(),d=r("p"),d.textContent=at,S=i(),h=r("p"),h.innerHTML=rt,R=i(),X(_.$$.fragment),Z=i(),$=r("p"),$.textContent=pt,J=i(),P=r("table"),P.innerHTML=st,j=i(),X(x.$$.fragment),W=i(),C=r("p"),C.innerHTML=ot,Y=i(),X(g.$$.fragment),N=i(),b=r("p"),b.innerHTML=mt,Q=i(),v=r("p"),v.innerHTML=ft,D=i(),T=r("ul"),T.innerHTML=ut,K=i(),X(w.$$.fragment),O=i(),M=r("p"),M.innerHTML=ct,tt=i(),A=r("p"),this.h()},l(t){const e=gt("svelte-u9bgzb",document.head);o=p(e,"META",{name:!0,content:!0}),e.forEach(l),B=a(t),L=p(t,"P",{}),dt(L).forEach(l),F=a(t),I(m.$$.fragment,t),V=a(t),f=p(t,"P",{"data-svelte-h":!0}),s(f)!=="svelte-1hdugqm"&&(f.textContent=nt),q=a(t),I(u.$$.fragment,t),z=a(t),c=p(t,"P",{"data-svelte-h":!0}),s(c)!=="svelte-40eybl"&&(c.textContent=it),G=a(t),d=p(t,"P",{"data-svelte-h":!0}),s(d)!=="svelte-pijyqv"&&(d.textContent=at),S=a(t),h=p(t,"P",{"data-svelte-h":!0}),s(h)!=="svelte-nnpzlr"&&(h.innerHTML=rt),R=a(t),I(_.$$.fragment,t),Z=a(t),$=p(t,"P",{"data-svelte-h":!0}),s($)!=="svelte-armibm"&&($.textContent=pt),J=a(t),P=p(t,"TABLE",{"data-svelte-h":!0}),s(P)!=="svelte-okkx16"&&(P.innerHTML=st),j=a(t),I(x.$$.fragment,t),W=a(t),C=p(t,"P",{"data-svelte-h":!0}),s(C)!=="svelte-ipbj1s"&&(C.innerHTML=ot),Y=a(t),I(g.$$.fragment,t),N=a(t),b=p(t,"P",{"data-svelte-h":!0}),s(b)!=="svelte-10c35bg"&&(b.innerHTML=mt),Q=a(t),v=p(t,"P",{"data-svelte-h":!0}),s(v)!=="svelte-152wvr6"&&(v.innerHTML=ft),D=a(t),T=p(t,"UL",{"data-svelte-h":!0}),s(T)!=="svelte-ncvo0w"&&(T.innerHTML=ut),K=a(t),I(w.$$.fragment,t),O=a(t),M=p(t,"P",{"data-svelte-h":!0}),s(M)!=="svelte-51a2ou"&&(M.innerHTML=ct),tt=a(t),A=p(t,"P",{}),dt(A).forEach(l),this.h()},h(){ht(o,"name","hf:doc:metadata"),ht(o,"content",wt)},m(t,e){bt(document.head,o),n(t,B,e),n(t,L,e),n(t,F,e),y(m,t,e),n(t,V,e),n(t,f,e),n(t,q,e),y(u,t,e),n(t,z,e),n(t,c,e),n(t,G,e),n(t,d,e),n(t,S,e),n(t,h,e),n(t,R,e),y(_,t,e),n(t,Z,e),n(t,$,e),n(t,J,e),n(t,P,e),n(t,j,e),y(x,t,e),n(t,W,e),n(t,C,e),n(t,Y,e),y(g,t,e),n(t,N,e),n(t,b,e),n(t,Q,e),n(t,v,e),n(t,D,e),n(t,T,e),n(t,K,e),y(w,t,e),n(t,O,e),n(t,M,e),n(t,tt,e),n(t,A,e),et=!0},p:$t,i(t){et||(E(m.$$.fragment,t),E(u.$$.fragment,t),E(_.$$.fragment,t),E(x.$$.fragment,t),E(g.$$.fragment,t),E(w.$$.fragment,t),et=!0)},o(t){U(m.$$.fragment,t),U(u.$$.fragment,t),U(_.$$.fragment,t),U(x.$$.fragment,t),U(g.$$.fragment,t),U(w.$$.fragment,t),et=!1},d(t){t&&(l(B),l(L),l(F),l(V),l(f),l(q),l(z),l(c),l(G),l(d),l(S),l(h),l(R),l(Z),l($),l(J),l(P),l(j),l(W),l(C),l(Y),l(N),l(b),l(Q),l(v),l(D),l(T),l(K),l(O),l(M),l(tt),l(A)),l(o),H(m,t),H(u,t),H(_,t),H(x,t),H(g,t),H(w,t)}}}const wt='{"title":"CPU에서 효율적인 훈련","local":"efficient-training-on-cpu","sections":[{"title":"IPEX와 혼합 정밀도","local":"mixed-precision-with-ipex","sections":[{"title":"IPEX 설치:","local":"ipex-installation","sections":[],"depth":3},{"title":"Trainer에서의 사용법","local":"usage-in-trainer","sections":[],"depth":3},{"title":"실습 예시","local":"practice-example","sections":[],"depth":3}],"depth":2}],"depth":1}';function Mt(lt){return Pt(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Ut extends xt{constructor(o){super(),Ct(this,o,Mt,Tt,_t,{})}}export{Ut as component};
